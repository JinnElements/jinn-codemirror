{
  "version": 3,
  "sources": ["../node_modules/@lezer/common/dist/index.js", "../node_modules/@lezer/lr/dist/index.js", "../src/parser/leiden+/parser.terms.js", "../src/parser/tokens.ts", "../src/parser/leiden+/parser.js", "../src/import/leiden+2xml.ts"],
  "sourcesContent": ["// FIXME profile adding a per-Tree TreeNode cache, validating it by\n// parent pointer\n/// The default maximum length of a `TreeBuffer` node.\nconst DefaultBufferLength = 1024;\nlet nextPropID = 0;\nclass Range {\n    constructor(from, to) {\n        this.from = from;\n        this.to = to;\n    }\n}\n/// Each [node type](#common.NodeType) or [individual tree](#common.Tree)\n/// can have metadata associated with it in props. Instances of this\n/// class represent prop names.\nclass NodeProp {\n    /// Create a new node prop type.\n    constructor(config = {}) {\n        this.id = nextPropID++;\n        this.perNode = !!config.perNode;\n        this.deserialize = config.deserialize || (() => {\n            throw new Error(\"This node type doesn't define a deserialize function\");\n        });\n    }\n    /// This is meant to be used with\n    /// [`NodeSet.extend`](#common.NodeSet.extend) or\n    /// [`LRParser.configure`](#lr.ParserConfig.props) to compute\n    /// prop values for each node type in the set. Takes a [match\n    /// object](#common.NodeType^match) or function that returns undefined\n    /// if the node type doesn't get this prop, and the prop's value if\n    /// it does.\n    add(match) {\n        if (this.perNode)\n            throw new RangeError(\"Can't add per-node props to node types\");\n        if (typeof match != \"function\")\n            match = NodeType.match(match);\n        return (type) => {\n            let result = match(type);\n            return result === undefined ? null : [this, result];\n        };\n    }\n}\n/// Prop that is used to describe matching delimiters. For opening\n/// delimiters, this holds an array of node names (written as a\n/// space-separated string when declaring this prop in a grammar)\n/// for the node types of closing delimiters that match it.\nNodeProp.closedBy = new NodeProp({ deserialize: str => str.split(\" \") });\n/// The inverse of [`closedBy`](#common.NodeProp^closedBy). This is\n/// attached to closing delimiters, holding an array of node names\n/// of types of matching opening delimiters.\nNodeProp.openedBy = new NodeProp({ deserialize: str => str.split(\" \") });\n/// Used to assign node types to groups (for example, all node\n/// types that represent an expression could be tagged with an\n/// `\"Expression\"` group).\nNodeProp.group = new NodeProp({ deserialize: str => str.split(\" \") });\n/// The hash of the [context](#lr.ContextTracker.constructor)\n/// that the node was parsed in, if any. Used to limit reuse of\n/// contextual nodes.\nNodeProp.contextHash = new NodeProp({ perNode: true });\n/// The distance beyond the end of the node that the tokenizer\n/// looked ahead for any of the tokens inside the node. (The LR\n/// parser only stores this when it is larger than 25, for\n/// efficiency reasons.)\nNodeProp.lookAhead = new NodeProp({ perNode: true });\n/// This per-node prop is used to replace a given node, or part of a\n/// node, with another tree. This is useful to include trees from\n/// different languages in mixed-language parsers.\nNodeProp.mounted = new NodeProp({ perNode: true });\n/// A mounted tree, which can be [stored](#common.NodeProp^mounted) on\n/// a tree node to indicate that parts of its content are\n/// represented by another tree.\nclass MountedTree {\n    constructor(\n    /// The inner tree.\n    tree, \n    /// If this is null, this tree replaces the entire node (it will\n    /// be included in the regular iteration instead of its host\n    /// node). If not, only the given ranges are considered to be\n    /// covered by this tree. This is used for trees that are mixed in\n    /// a way that isn't strictly hierarchical. Such mounted trees are\n    /// only entered by [`resolveInner`](#common.Tree.resolveInner)\n    /// and [`enter`](#common.SyntaxNode.enter).\n    overlay, \n    /// The parser used to create this subtree.\n    parser) {\n        this.tree = tree;\n        this.overlay = overlay;\n        this.parser = parser;\n    }\n}\nconst noProps = Object.create(null);\n/// Each node in a syntax tree has a node type associated with it.\nclass NodeType {\n    /// @internal\n    constructor(\n    /// The name of the node type. Not necessarily unique, but if the\n    /// grammar was written properly, different node types with the\n    /// same name within a node set should play the same semantic\n    /// role.\n    name, \n    /// @internal\n    props, \n    /// The id of this node in its set. Corresponds to the term ids\n    /// used in the parser.\n    id, \n    /// @internal\n    flags = 0) {\n        this.name = name;\n        this.props = props;\n        this.id = id;\n        this.flags = flags;\n    }\n    /// Define a node type.\n    static define(spec) {\n        let props = spec.props && spec.props.length ? Object.create(null) : noProps;\n        let flags = (spec.top ? 1 /* Top */ : 0) | (spec.skipped ? 2 /* Skipped */ : 0) |\n            (spec.error ? 4 /* Error */ : 0) | (spec.name == null ? 8 /* Anonymous */ : 0);\n        let type = new NodeType(spec.name || \"\", props, spec.id, flags);\n        if (spec.props)\n            for (let src of spec.props) {\n                if (!Array.isArray(src))\n                    src = src(type);\n                if (src) {\n                    if (src[0].perNode)\n                        throw new RangeError(\"Can't store a per-node prop on a node type\");\n                    props[src[0].id] = src[1];\n                }\n            }\n        return type;\n    }\n    /// Retrieves a node prop for this type. Will return `undefined` if\n    /// the prop isn't present on this node.\n    prop(prop) { return this.props[prop.id]; }\n    /// True when this is the top node of a grammar.\n    get isTop() { return (this.flags & 1 /* Top */) > 0; }\n    /// True when this node is produced by a skip rule.\n    get isSkipped() { return (this.flags & 2 /* Skipped */) > 0; }\n    /// Indicates whether this is an error node.\n    get isError() { return (this.flags & 4 /* Error */) > 0; }\n    /// When true, this node type doesn't correspond to a user-declared\n    /// named node, for example because it is used to cache repetition.\n    get isAnonymous() { return (this.flags & 8 /* Anonymous */) > 0; }\n    /// Returns true when this node's name or one of its\n    /// [groups](#common.NodeProp^group) matches the given string.\n    is(name) {\n        if (typeof name == 'string') {\n            if (this.name == name)\n                return true;\n            let group = this.prop(NodeProp.group);\n            return group ? group.indexOf(name) > -1 : false;\n        }\n        return this.id == name;\n    }\n    /// Create a function from node types to arbitrary values by\n    /// specifying an object whose property names are node or\n    /// [group](#common.NodeProp^group) names. Often useful with\n    /// [`NodeProp.add`](#common.NodeProp.add). You can put multiple\n    /// names, separated by spaces, in a single property name to map\n    /// multiple node names to a single value.\n    static match(map) {\n        let direct = Object.create(null);\n        for (let prop in map)\n            for (let name of prop.split(\" \"))\n                direct[name] = map[prop];\n        return (node) => {\n            for (let groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++) {\n                let found = direct[i < 0 ? node.name : groups[i]];\n                if (found)\n                    return found;\n            }\n        };\n    }\n}\n/// An empty dummy node type to use when no actual type is available.\nNodeType.none = new NodeType(\"\", Object.create(null), 0, 8 /* Anonymous */);\n/// A node set holds a collection of node types. It is used to\n/// compactly represent trees by storing their type ids, rather than a\n/// full pointer to the type object, in a numeric array. Each parser\n/// [has](#lr.LRParser.nodeSet) a node set, and [tree\n/// buffers](#common.TreeBuffer) can only store collections of nodes\n/// from the same set. A set can have a maximum of 2**16 (65536) node\n/// types in it, so that the ids fit into 16-bit typed array slots.\nclass NodeSet {\n    /// Create a set with the given types. The `id` property of each\n    /// type should correspond to its position within the array.\n    constructor(\n    /// The node types in this set, by id.\n    types) {\n        this.types = types;\n        for (let i = 0; i < types.length; i++)\n            if (types[i].id != i)\n                throw new RangeError(\"Node type ids should correspond to array positions when creating a node set\");\n    }\n    /// Create a copy of this set with some node properties added. The\n    /// arguments to this method can be created with\n    /// [`NodeProp.add`](#common.NodeProp.add).\n    extend(...props) {\n        let newTypes = [];\n        for (let type of this.types) {\n            let newProps = null;\n            for (let source of props) {\n                let add = source(type);\n                if (add) {\n                    if (!newProps)\n                        newProps = Object.assign({}, type.props);\n                    newProps[add[0].id] = add[1];\n                }\n            }\n            newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);\n        }\n        return new NodeSet(newTypes);\n    }\n}\nconst CachedNode = new WeakMap(), CachedInnerNode = new WeakMap();\n/// Options that control iteration. Can be combined with the `|`\n/// operator to enable multiple ones.\nvar IterMode;\n(function (IterMode) {\n    /// When enabled, iteration will only visit [`Tree`](#common.Tree)\n    /// objects, not nodes packed into\n    /// [`TreeBuffer`](#common.TreeBuffer)s.\n    IterMode[IterMode[\"ExcludeBuffers\"] = 1] = \"ExcludeBuffers\";\n    /// Enable this to make iteration include anonymous nodes (such as\n    /// the nodes that wrap repeated grammar constructs into a balanced\n    /// tree).\n    IterMode[IterMode[\"IncludeAnonymous\"] = 2] = \"IncludeAnonymous\";\n    /// By default, regular [mounted](#common.NodeProp^mounted) nodes\n    /// replace their base node in iteration. Enable this to ignore them\n    /// instead.\n    IterMode[IterMode[\"IgnoreMounts\"] = 4] = \"IgnoreMounts\";\n    /// This option only applies in\n    /// [`enter`](#common.SyntaxNode.enter)-style methods. It tells the\n    /// library to not enter mounted overlays if one covers the given\n    /// position.\n    IterMode[IterMode[\"IgnoreOverlays\"] = 8] = \"IgnoreOverlays\";\n})(IterMode || (IterMode = {}));\n/// A piece of syntax tree. There are two ways to approach these\n/// trees: the way they are actually stored in memory, and the\n/// convenient way.\n///\n/// Syntax trees are stored as a tree of `Tree` and `TreeBuffer`\n/// objects. By packing detail information into `TreeBuffer` leaf\n/// nodes, the representation is made a lot more memory-efficient.\n///\n/// However, when you want to actually work with tree nodes, this\n/// representation is very awkward, so most client code will want to\n/// use the [`TreeCursor`](#common.TreeCursor) or\n/// [`SyntaxNode`](#common.SyntaxNode) interface instead, which provides\n/// a view on some part of this data structure, and can be used to\n/// move around to adjacent nodes.\nclass Tree {\n    /// Construct a new tree. See also [`Tree.build`](#common.Tree^build).\n    constructor(\n    /// The type of the top node.\n    type, \n    /// This node's child nodes.\n    children, \n    /// The positions (offsets relative to the start of this tree) of\n    /// the children.\n    positions, \n    /// The total length of this tree\n    length, \n    /// Per-node [node props](#common.NodeProp) to associate with this node.\n    props) {\n        this.type = type;\n        this.children = children;\n        this.positions = positions;\n        this.length = length;\n        /// @internal\n        this.props = null;\n        if (props && props.length) {\n            this.props = Object.create(null);\n            for (let [prop, value] of props)\n                this.props[typeof prop == \"number\" ? prop : prop.id] = value;\n        }\n    }\n    /// @internal\n    toString() {\n        let mounted = this.prop(NodeProp.mounted);\n        if (mounted && !mounted.overlay)\n            return mounted.tree.toString();\n        let children = \"\";\n        for (let ch of this.children) {\n            let str = ch.toString();\n            if (str) {\n                if (children)\n                    children += \",\";\n                children += str;\n            }\n        }\n        return !this.type.name ? children :\n            (/\\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) +\n                (children.length ? \"(\" + children + \")\" : \"\");\n    }\n    /// Get a [tree cursor](#common.TreeCursor) positioned at the top of\n    /// the tree. Mode can be used to [control](#common.IterMode) which\n    /// nodes the cursor visits.\n    cursor(mode = 0) {\n        return new TreeCursor(this.topNode, mode);\n    }\n    /// Get a [tree cursor](#common.TreeCursor) pointing into this tree\n    /// at the given position and side (see\n    /// [`moveTo`](#common.TreeCursor.moveTo).\n    cursorAt(pos, side = 0, mode = 0) {\n        let scope = CachedNode.get(this) || this.topNode;\n        let cursor = new TreeCursor(scope);\n        cursor.moveTo(pos, side);\n        CachedNode.set(this, cursor._tree);\n        return cursor;\n    }\n    /// Get a [syntax node](#common.SyntaxNode) object for the top of the\n    /// tree.\n    get topNode() {\n        return new TreeNode(this, 0, 0, null);\n    }\n    /// Get the [syntax node](#common.SyntaxNode) at the given position.\n    /// If `side` is -1, this will move into nodes that end at the\n    /// position. If 1, it'll move into nodes that start at the\n    /// position. With 0, it'll only enter nodes that cover the position\n    /// from both sides.\n    ///\n    /// Note that this will not enter\n    /// [overlays](#common.MountedTree.overlay), and you often want\n    /// [`resolveInner`](#common.Tree.resolveInner) instead.\n    resolve(pos, side = 0) {\n        let node = resolveNode(CachedNode.get(this) || this.topNode, pos, side, false);\n        CachedNode.set(this, node);\n        return node;\n    }\n    /// Like [`resolve`](#common.Tree.resolve), but will enter\n    /// [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node\n    /// pointing into the innermost overlaid tree at the given position\n    /// (with parent links going through all parent structure, including\n    /// the host trees).\n    resolveInner(pos, side = 0) {\n        let node = resolveNode(CachedInnerNode.get(this) || this.topNode, pos, side, true);\n        CachedInnerNode.set(this, node);\n        return node;\n    }\n    /// Iterate over the tree and its children, calling `enter` for any\n    /// node that touches the `from`/`to` region (if given) before\n    /// running over such a node's children, and `leave` (if given) when\n    /// leaving the node. When `enter` returns `false`, that node will\n    /// not have its children iterated over (or `leave` called).\n    iterate(spec) {\n        let { enter, leave, from = 0, to = this.length } = spec;\n        for (let c = this.cursor((spec.mode || 0) | IterMode.IncludeAnonymous);;) {\n            let entered = false;\n            if (c.from <= to && c.to >= from && (c.type.isAnonymous || enter(c) !== false)) {\n                if (c.firstChild())\n                    continue;\n                entered = true;\n            }\n            for (;;) {\n                if (entered && leave && !c.type.isAnonymous)\n                    leave(c);\n                if (c.nextSibling())\n                    break;\n                if (!c.parent())\n                    return;\n                entered = true;\n            }\n        }\n    }\n    /// Get the value of the given [node prop](#common.NodeProp) for this\n    /// node. Works with both per-node and per-type props.\n    prop(prop) {\n        return !prop.perNode ? this.type.prop(prop) : this.props ? this.props[prop.id] : undefined;\n    }\n    /// Returns the node's [per-node props](#common.NodeProp.perNode) in a\n    /// format that can be passed to the [`Tree`](#common.Tree)\n    /// constructor.\n    get propValues() {\n        let result = [];\n        if (this.props)\n            for (let id in this.props)\n                result.push([+id, this.props[id]]);\n        return result;\n    }\n    /// Balance the direct children of this tree, producing a copy of\n    /// which may have children grouped into subtrees with type\n    /// [`NodeType.none`](#common.NodeType^none).\n    balance(config = {}) {\n        return this.children.length <= 8 /* BranchFactor */ ? this :\n            balanceRange(NodeType.none, this.children, this.positions, 0, this.children.length, 0, this.length, (children, positions, length) => new Tree(this.type, children, positions, length, this.propValues), config.makeTree || ((children, positions, length) => new Tree(NodeType.none, children, positions, length)));\n    }\n    /// Build a tree from a postfix-ordered buffer of node information,\n    /// or a cursor over such a buffer.\n    static build(data) { return buildTree(data); }\n}\n/// The empty tree\nTree.empty = new Tree(NodeType.none, [], [], 0);\nclass FlatBufferCursor {\n    constructor(buffer, index) {\n        this.buffer = buffer;\n        this.index = index;\n    }\n    get id() { return this.buffer[this.index - 4]; }\n    get start() { return this.buffer[this.index - 3]; }\n    get end() { return this.buffer[this.index - 2]; }\n    get size() { return this.buffer[this.index - 1]; }\n    get pos() { return this.index; }\n    next() { this.index -= 4; }\n    fork() { return new FlatBufferCursor(this.buffer, this.index); }\n}\n/// Tree buffers contain (type, start, end, endIndex) quads for each\n/// node. In such a buffer, nodes are stored in prefix order (parents\n/// before children, with the endIndex of the parent indicating which\n/// children belong to it).\nclass TreeBuffer {\n    /// Create a tree buffer.\n    constructor(\n    /// The buffer's content.\n    buffer, \n    /// The total length of the group of nodes in the buffer.\n    length, \n    /// The node set used in this buffer.\n    set) {\n        this.buffer = buffer;\n        this.length = length;\n        this.set = set;\n    }\n    /// @internal\n    get type() { return NodeType.none; }\n    /// @internal\n    toString() {\n        let result = [];\n        for (let index = 0; index < this.buffer.length;) {\n            result.push(this.childString(index));\n            index = this.buffer[index + 3];\n        }\n        return result.join(\",\");\n    }\n    /// @internal\n    childString(index) {\n        let id = this.buffer[index], endIndex = this.buffer[index + 3];\n        let type = this.set.types[id], result = type.name;\n        if (/\\W/.test(result) && !type.isError)\n            result = JSON.stringify(result);\n        index += 4;\n        if (endIndex == index)\n            return result;\n        let children = [];\n        while (index < endIndex) {\n            children.push(this.childString(index));\n            index = this.buffer[index + 3];\n        }\n        return result + \"(\" + children.join(\",\") + \")\";\n    }\n    /// @internal\n    findChild(startIndex, endIndex, dir, pos, side) {\n        let { buffer } = this, pick = -1;\n        for (let i = startIndex; i != endIndex; i = buffer[i + 3]) {\n            if (checkSide(side, pos, buffer[i + 1], buffer[i + 2])) {\n                pick = i;\n                if (dir > 0)\n                    break;\n            }\n        }\n        return pick;\n    }\n    /// @internal\n    slice(startI, endI, from, to) {\n        let b = this.buffer;\n        let copy = new Uint16Array(endI - startI);\n        for (let i = startI, j = 0; i < endI;) {\n            copy[j++] = b[i++];\n            copy[j++] = b[i++] - from;\n            copy[j++] = b[i++] - from;\n            copy[j++] = b[i++] - startI;\n        }\n        return new TreeBuffer(copy, to - from, this.set);\n    }\n}\nfunction checkSide(side, pos, from, to) {\n    switch (side) {\n        case -2 /* Before */: return from < pos;\n        case -1 /* AtOrBefore */: return to >= pos && from < pos;\n        case 0 /* Around */: return from < pos && to > pos;\n        case 1 /* AtOrAfter */: return from <= pos && to > pos;\n        case 2 /* After */: return to > pos;\n        case 4 /* DontCare */: return true;\n    }\n}\nfunction enterUnfinishedNodesBefore(node, pos) {\n    let scan = node.childBefore(pos);\n    while (scan) {\n        let last = scan.lastChild;\n        if (!last || last.to != scan.to)\n            break;\n        if (last.type.isError && last.from == last.to) {\n            node = scan;\n            scan = last.prevSibling;\n        }\n        else {\n            scan = last;\n        }\n    }\n    return node;\n}\nfunction resolveNode(node, pos, side, overlays) {\n    var _a;\n    // Move up to a node that actually holds the position, if possible\n    while (node.from == node.to ||\n        (side < 1 ? node.from >= pos : node.from > pos) ||\n        (side > -1 ? node.to <= pos : node.to < pos)) {\n        let parent = !overlays && node instanceof TreeNode && node.index < 0 ? null : node.parent;\n        if (!parent)\n            return node;\n        node = parent;\n    }\n    let mode = overlays ? 0 : IterMode.IgnoreOverlays;\n    // Must go up out of overlays when those do not overlap with pos\n    if (overlays)\n        for (let scan = node, parent = scan.parent; parent; scan = parent, parent = scan.parent) {\n            if (scan instanceof TreeNode && scan.index < 0 && ((_a = parent.enter(pos, side, mode)) === null || _a === void 0 ? void 0 : _a.from) != scan.from)\n                node = parent;\n        }\n    for (;;) {\n        let inner = node.enter(pos, side, mode);\n        if (!inner)\n            return node;\n        node = inner;\n    }\n}\nclass TreeNode {\n    constructor(_tree, from, \n    // Index in parent node, set to -1 if the node is not a direct child of _parent.node (overlay)\n    index, _parent) {\n        this._tree = _tree;\n        this.from = from;\n        this.index = index;\n        this._parent = _parent;\n    }\n    get type() { return this._tree.type; }\n    get name() { return this._tree.type.name; }\n    get to() { return this.from + this._tree.length; }\n    nextChild(i, dir, pos, side, mode = 0) {\n        for (let parent = this;;) {\n            for (let { children, positions } = parent._tree, e = dir > 0 ? children.length : -1; i != e; i += dir) {\n                let next = children[i], start = positions[i] + parent.from;\n                if (!checkSide(side, pos, start, start + next.length))\n                    continue;\n                if (next instanceof TreeBuffer) {\n                    if (mode & IterMode.ExcludeBuffers)\n                        continue;\n                    let index = next.findChild(0, next.buffer.length, dir, pos - start, side);\n                    if (index > -1)\n                        return new BufferNode(new BufferContext(parent, next, i, start), null, index);\n                }\n                else if ((mode & IterMode.IncludeAnonymous) || (!next.type.isAnonymous || hasChild(next))) {\n                    let mounted;\n                    if (!(mode & IterMode.IgnoreMounts) &&\n                        next.props && (mounted = next.prop(NodeProp.mounted)) && !mounted.overlay)\n                        return new TreeNode(mounted.tree, start, i, parent);\n                    let inner = new TreeNode(next, start, i, parent);\n                    return (mode & IterMode.IncludeAnonymous) || !inner.type.isAnonymous ? inner\n                        : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, pos, side);\n                }\n            }\n            if ((mode & IterMode.IncludeAnonymous) || !parent.type.isAnonymous)\n                return null;\n            if (parent.index >= 0)\n                i = parent.index + dir;\n            else\n                i = dir < 0 ? -1 : parent._parent._tree.children.length;\n            parent = parent._parent;\n            if (!parent)\n                return null;\n        }\n    }\n    get firstChild() { return this.nextChild(0, 1, 0, 4 /* DontCare */); }\n    get lastChild() { return this.nextChild(this._tree.children.length - 1, -1, 0, 4 /* DontCare */); }\n    childAfter(pos) { return this.nextChild(0, 1, pos, 2 /* After */); }\n    childBefore(pos) { return this.nextChild(this._tree.children.length - 1, -1, pos, -2 /* Before */); }\n    enter(pos, side, mode = 0) {\n        let mounted;\n        if (!(mode & IterMode.IgnoreOverlays) && (mounted = this._tree.prop(NodeProp.mounted)) && mounted.overlay) {\n            let rPos = pos - this.from;\n            for (let { from, to } of mounted.overlay) {\n                if ((side > 0 ? from <= rPos : from < rPos) &&\n                    (side < 0 ? to >= rPos : to > rPos))\n                    return new TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this);\n            }\n        }\n        return this.nextChild(0, 1, pos, side, mode);\n    }\n    nextSignificantParent() {\n        let val = this;\n        while (val.type.isAnonymous && val._parent)\n            val = val._parent;\n        return val;\n    }\n    get parent() {\n        return this._parent ? this._parent.nextSignificantParent() : null;\n    }\n    get nextSibling() {\n        return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, 4 /* DontCare */) : null;\n    }\n    get prevSibling() {\n        return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, 4 /* DontCare */) : null;\n    }\n    cursor(mode = 0) { return new TreeCursor(this, mode); }\n    get tree() { return this._tree; }\n    toTree() { return this._tree; }\n    resolve(pos, side = 0) {\n        return resolveNode(this, pos, side, false);\n    }\n    resolveInner(pos, side = 0) {\n        return resolveNode(this, pos, side, true);\n    }\n    enterUnfinishedNodesBefore(pos) { return enterUnfinishedNodesBefore(this, pos); }\n    getChild(type, before = null, after = null) {\n        let r = getChildren(this, type, before, after);\n        return r.length ? r[0] : null;\n    }\n    getChildren(type, before = null, after = null) {\n        return getChildren(this, type, before, after);\n    }\n    /// @internal\n    toString() { return this._tree.toString(); }\n    get node() { return this; }\n    matchContext(context) { return matchNodeContext(this, context); }\n}\nfunction getChildren(node, type, before, after) {\n    let cur = node.cursor(), result = [];\n    if (!cur.firstChild())\n        return result;\n    if (before != null)\n        while (!cur.type.is(before))\n            if (!cur.nextSibling())\n                return result;\n    for (;;) {\n        if (after != null && cur.type.is(after))\n            return result;\n        if (cur.type.is(type))\n            result.push(cur.node);\n        if (!cur.nextSibling())\n            return after == null ? result : [];\n    }\n}\nfunction matchNodeContext(node, context, i = context.length - 1) {\n    for (let p = node.parent; i >= 0; p = p.parent) {\n        if (!p)\n            return false;\n        if (!p.type.isAnonymous) {\n            if (context[i] && context[i] != p.name)\n                return false;\n            i--;\n        }\n    }\n    return true;\n}\nclass BufferContext {\n    constructor(parent, buffer, index, start) {\n        this.parent = parent;\n        this.buffer = buffer;\n        this.index = index;\n        this.start = start;\n    }\n}\nclass BufferNode {\n    constructor(context, _parent, index) {\n        this.context = context;\n        this._parent = _parent;\n        this.index = index;\n        this.type = context.buffer.set.types[context.buffer.buffer[index]];\n    }\n    get name() { return this.type.name; }\n    get from() { return this.context.start + this.context.buffer.buffer[this.index + 1]; }\n    get to() { return this.context.start + this.context.buffer.buffer[this.index + 2]; }\n    child(dir, pos, side) {\n        let { buffer } = this.context;\n        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);\n        return index < 0 ? null : new BufferNode(this.context, this, index);\n    }\n    get firstChild() { return this.child(1, 0, 4 /* DontCare */); }\n    get lastChild() { return this.child(-1, 0, 4 /* DontCare */); }\n    childAfter(pos) { return this.child(1, pos, 2 /* After */); }\n    childBefore(pos) { return this.child(-1, pos, -2 /* Before */); }\n    enter(pos, side, mode = 0) {\n        if (mode & IterMode.ExcludeBuffers)\n            return null;\n        let { buffer } = this.context;\n        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);\n        return index < 0 ? null : new BufferNode(this.context, this, index);\n    }\n    get parent() {\n        return this._parent || this.context.parent.nextSignificantParent();\n    }\n    externalSibling(dir) {\n        return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, 0, 4 /* DontCare */);\n    }\n    get nextSibling() {\n        let { buffer } = this.context;\n        let after = buffer.buffer[this.index + 3];\n        if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))\n            return new BufferNode(this.context, this._parent, after);\n        return this.externalSibling(1);\n    }\n    get prevSibling() {\n        let { buffer } = this.context;\n        let parentStart = this._parent ? this._parent.index + 4 : 0;\n        if (this.index == parentStart)\n            return this.externalSibling(-1);\n        return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, 0, 4 /* DontCare */));\n    }\n    cursor(mode = 0) { return new TreeCursor(this, mode); }\n    get tree() { return null; }\n    toTree() {\n        let children = [], positions = [];\n        let { buffer } = this.context;\n        let startI = this.index + 4, endI = buffer.buffer[this.index + 3];\n        if (endI > startI) {\n            let from = buffer.buffer[this.index + 1], to = buffer.buffer[this.index + 2];\n            children.push(buffer.slice(startI, endI, from, to));\n            positions.push(0);\n        }\n        return new Tree(this.type, children, positions, this.to - this.from);\n    }\n    resolve(pos, side = 0) {\n        return resolveNode(this, pos, side, false);\n    }\n    resolveInner(pos, side = 0) {\n        return resolveNode(this, pos, side, true);\n    }\n    enterUnfinishedNodesBefore(pos) { return enterUnfinishedNodesBefore(this, pos); }\n    /// @internal\n    toString() { return this.context.buffer.childString(this.index); }\n    getChild(type, before = null, after = null) {\n        let r = getChildren(this, type, before, after);\n        return r.length ? r[0] : null;\n    }\n    getChildren(type, before = null, after = null) {\n        return getChildren(this, type, before, after);\n    }\n    get node() { return this; }\n    matchContext(context) { return matchNodeContext(this, context); }\n}\n/// A tree cursor object focuses on a given node in a syntax tree, and\n/// allows you to move to adjacent nodes.\nclass TreeCursor {\n    /// @internal\n    constructor(node, \n    /// @internal\n    mode = 0) {\n        this.mode = mode;\n        /// @internal\n        this.buffer = null;\n        this.stack = [];\n        /// @internal\n        this.index = 0;\n        this.bufferNode = null;\n        if (node instanceof TreeNode) {\n            this.yieldNode(node);\n        }\n        else {\n            this._tree = node.context.parent;\n            this.buffer = node.context;\n            for (let n = node._parent; n; n = n._parent)\n                this.stack.unshift(n.index);\n            this.bufferNode = node;\n            this.yieldBuf(node.index);\n        }\n    }\n    /// Shorthand for `.type.name`.\n    get name() { return this.type.name; }\n    yieldNode(node) {\n        if (!node)\n            return false;\n        this._tree = node;\n        this.type = node.type;\n        this.from = node.from;\n        this.to = node.to;\n        return true;\n    }\n    yieldBuf(index, type) {\n        this.index = index;\n        let { start, buffer } = this.buffer;\n        this.type = type || buffer.set.types[buffer.buffer[index]];\n        this.from = start + buffer.buffer[index + 1];\n        this.to = start + buffer.buffer[index + 2];\n        return true;\n    }\n    yield(node) {\n        if (!node)\n            return false;\n        if (node instanceof TreeNode) {\n            this.buffer = null;\n            return this.yieldNode(node);\n        }\n        this.buffer = node.context;\n        return this.yieldBuf(node.index, node.type);\n    }\n    /// @internal\n    toString() {\n        return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();\n    }\n    /// @internal\n    enterChild(dir, pos, side) {\n        if (!this.buffer)\n            return this.yield(this._tree.nextChild(dir < 0 ? this._tree._tree.children.length - 1 : 0, dir, pos, side, this.mode));\n        let { buffer } = this.buffer;\n        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);\n        if (index < 0)\n            return false;\n        this.stack.push(this.index);\n        return this.yieldBuf(index);\n    }\n    /// Move the cursor to this node's first child. When this returns\n    /// false, the node has no child, and the cursor has not been moved.\n    firstChild() { return this.enterChild(1, 0, 4 /* DontCare */); }\n    /// Move the cursor to this node's last child.\n    lastChild() { return this.enterChild(-1, 0, 4 /* DontCare */); }\n    /// Move the cursor to the first child that ends after `pos`.\n    childAfter(pos) { return this.enterChild(1, pos, 2 /* After */); }\n    /// Move to the last child that starts before `pos`.\n    childBefore(pos) { return this.enterChild(-1, pos, -2 /* Before */); }\n    /// Move the cursor to the child around `pos`. If side is -1 the\n    /// child may end at that position, when 1 it may start there. This\n    /// will also enter [overlaid](#common.MountedTree.overlay)\n    /// [mounted](#common.NodeProp^mounted) trees unless `overlays` is\n    /// set to false.\n    enter(pos, side, mode = this.mode) {\n        if (!this.buffer)\n            return this.yield(this._tree.enter(pos, side, mode));\n        return mode & IterMode.ExcludeBuffers ? false : this.enterChild(1, pos, side);\n    }\n    /// Move to the node's parent node, if this isn't the top node.\n    parent() {\n        if (!this.buffer)\n            return this.yieldNode((this.mode & IterMode.IncludeAnonymous) ? this._tree._parent : this._tree.parent);\n        if (this.stack.length)\n            return this.yieldBuf(this.stack.pop());\n        let parent = (this.mode & IterMode.IncludeAnonymous) ? this.buffer.parent : this.buffer.parent.nextSignificantParent();\n        this.buffer = null;\n        return this.yieldNode(parent);\n    }\n    /// @internal\n    sibling(dir) {\n        if (!this.buffer)\n            return !this._tree._parent ? false\n                : this.yield(this._tree.index < 0 ? null\n                    : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4 /* DontCare */, this.mode));\n        let { buffer } = this.buffer, d = this.stack.length - 1;\n        if (dir < 0) {\n            let parentStart = d < 0 ? 0 : this.stack[d] + 4;\n            if (this.index != parentStart)\n                return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, 0, 4 /* DontCare */));\n        }\n        else {\n            let after = buffer.buffer[this.index + 3];\n            if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3]))\n                return this.yieldBuf(after);\n        }\n        return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4 /* DontCare */, this.mode)) : false;\n    }\n    /// Move to this node's next sibling, if any.\n    nextSibling() { return this.sibling(1); }\n    /// Move to this node's previous sibling, if any.\n    prevSibling() { return this.sibling(-1); }\n    atLastNode(dir) {\n        let index, parent, { buffer } = this;\n        if (buffer) {\n            if (dir > 0) {\n                if (this.index < buffer.buffer.buffer.length)\n                    return false;\n            }\n            else {\n                for (let i = 0; i < this.index; i++)\n                    if (buffer.buffer.buffer[i + 3] < this.index)\n                        return false;\n            }\n            ({ index, parent } = buffer);\n        }\n        else {\n            ({ index, _parent: parent } = this._tree);\n        }\n        for (; parent; { index, _parent: parent } = parent) {\n            if (index > -1)\n                for (let i = index + dir, e = dir < 0 ? -1 : parent._tree.children.length; i != e; i += dir) {\n                    let child = parent._tree.children[i];\n                    if ((this.mode & IterMode.IncludeAnonymous) ||\n                        child instanceof TreeBuffer ||\n                        !child.type.isAnonymous ||\n                        hasChild(child))\n                        return false;\n                }\n        }\n        return true;\n    }\n    move(dir, enter) {\n        if (enter && this.enterChild(dir, 0, 4 /* DontCare */))\n            return true;\n        for (;;) {\n            if (this.sibling(dir))\n                return true;\n            if (this.atLastNode(dir) || !this.parent())\n                return false;\n        }\n    }\n    /// Move to the next node in a\n    /// [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order_(NLR))\n    /// traversal, going from a node to its first child or, if the\n    /// current node is empty or `enter` is false, its next sibling or\n    /// the next sibling of the first parent node that has one.\n    next(enter = true) { return this.move(1, enter); }\n    /// Move to the next node in a last-to-first pre-order traveral. A\n    /// node is followed by its last child or, if it has none, its\n    /// previous sibling or the previous sibling of the first parent\n    /// node that has one.\n    prev(enter = true) { return this.move(-1, enter); }\n    /// Move the cursor to the innermost node that covers `pos`. If\n    /// `side` is -1, it will enter nodes that end at `pos`. If it is 1,\n    /// it will enter nodes that start at `pos`.\n    moveTo(pos, side = 0) {\n        // Move up to a node that actually holds the position, if possible\n        while (this.from == this.to ||\n            (side < 1 ? this.from >= pos : this.from > pos) ||\n            (side > -1 ? this.to <= pos : this.to < pos))\n            if (!this.parent())\n                break;\n        // Then scan down into child nodes as far as possible\n        while (this.enterChild(1, pos, side)) { }\n        return this;\n    }\n    /// Get a [syntax node](#common.SyntaxNode) at the cursor's current\n    /// position.\n    get node() {\n        if (!this.buffer)\n            return this._tree;\n        let cache = this.bufferNode, result = null, depth = 0;\n        if (cache && cache.context == this.buffer) {\n            scan: for (let index = this.index, d = this.stack.length; d >= 0;) {\n                for (let c = cache; c; c = c._parent)\n                    if (c.index == index) {\n                        if (index == this.index)\n                            return c;\n                        result = c;\n                        depth = d + 1;\n                        break scan;\n                    }\n                index = this.stack[--d];\n            }\n        }\n        for (let i = depth; i < this.stack.length; i++)\n            result = new BufferNode(this.buffer, result, this.stack[i]);\n        return this.bufferNode = new BufferNode(this.buffer, result, this.index);\n    }\n    /// Get the [tree](#common.Tree) that represents the current node, if\n    /// any. Will return null when the node is in a [tree\n    /// buffer](#common.TreeBuffer).\n    get tree() {\n        return this.buffer ? null : this._tree._tree;\n    }\n    /// Iterate over the current node and all its descendants, calling\n    /// `enter` when entering a node and `leave`, if given, when leaving\n    /// one. When `enter` returns `false`, any children of that node are\n    /// skipped, and `leave` isn't called for it.\n    iterate(enter, leave) {\n        for (let depth = 0;;) {\n            let mustLeave = false;\n            if (this.type.isAnonymous || enter(this) !== false) {\n                if (this.firstChild()) {\n                    depth++;\n                    continue;\n                }\n                if (!this.type.isAnonymous)\n                    mustLeave = true;\n            }\n            for (;;) {\n                if (mustLeave && leave)\n                    leave(this);\n                mustLeave = this.type.isAnonymous;\n                if (this.nextSibling())\n                    break;\n                if (!depth)\n                    return;\n                this.parent();\n                depth--;\n                mustLeave = true;\n            }\n        }\n    }\n    /// Test whether the current node matches a given context\u2014a sequence\n    /// of direct parent node names. Empty strings in the context array\n    /// are treated as wildcards.\n    matchContext(context) {\n        if (!this.buffer)\n            return matchNodeContext(this.node, context);\n        let { buffer } = this.buffer, { types } = buffer.set;\n        for (let i = context.length - 1, d = this.stack.length - 1; i >= 0; d--) {\n            if (d < 0)\n                return matchNodeContext(this.node, context, i);\n            let type = types[buffer.buffer[this.stack[d]]];\n            if (!type.isAnonymous) {\n                if (context[i] && context[i] != type.name)\n                    return false;\n                i--;\n            }\n        }\n        return true;\n    }\n}\nfunction hasChild(tree) {\n    return tree.children.some(ch => ch instanceof TreeBuffer || !ch.type.isAnonymous || hasChild(ch));\n}\nfunction buildTree(data) {\n    var _a;\n    let { buffer, nodeSet, maxBufferLength = DefaultBufferLength, reused = [], minRepeatType = nodeSet.types.length } = data;\n    let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;\n    let types = nodeSet.types;\n    let contextHash = 0, lookAhead = 0;\n    function takeNode(parentStart, minPos, children, positions, inRepeat) {\n        let { id, start, end, size } = cursor;\n        let lookAheadAtStart = lookAhead;\n        while (size < 0) {\n            cursor.next();\n            if (size == -1 /* Reuse */) {\n                let node = reused[id];\n                children.push(node);\n                positions.push(start - parentStart);\n                return;\n            }\n            else if (size == -3 /* ContextChange */) { // Context change\n                contextHash = id;\n                return;\n            }\n            else if (size == -4 /* LookAhead */) {\n                lookAhead = id;\n                return;\n            }\n            else {\n                throw new RangeError(`Unrecognized record size: ${size}`);\n            }\n        }\n        let type = types[id], node, buffer;\n        let startPos = start - parentStart;\n        if (end - start <= maxBufferLength && (buffer = findBufferSize(cursor.pos - minPos, inRepeat))) {\n            // Small enough for a buffer, and no reused nodes inside\n            let data = new Uint16Array(buffer.size - buffer.skip);\n            let endPos = cursor.pos - buffer.size, index = data.length;\n            while (cursor.pos > endPos)\n                index = copyToBuffer(buffer.start, data, index);\n            node = new TreeBuffer(data, end - buffer.start, nodeSet);\n            startPos = buffer.start - parentStart;\n        }\n        else { // Make it a node\n            let endPos = cursor.pos - size;\n            cursor.next();\n            let localChildren = [], localPositions = [];\n            let localInRepeat = id >= minRepeatType ? id : -1;\n            let lastGroup = 0, lastEnd = end;\n            while (cursor.pos > endPos) {\n                if (localInRepeat >= 0 && cursor.id == localInRepeat && cursor.size >= 0) {\n                    if (cursor.end <= lastEnd - maxBufferLength) {\n                        makeRepeatLeaf(localChildren, localPositions, start, lastGroup, cursor.end, lastEnd, localInRepeat, lookAheadAtStart);\n                        lastGroup = localChildren.length;\n                        lastEnd = cursor.end;\n                    }\n                    cursor.next();\n                }\n                else {\n                    takeNode(start, endPos, localChildren, localPositions, localInRepeat);\n                }\n            }\n            if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length)\n                makeRepeatLeaf(localChildren, localPositions, start, lastGroup, start, lastEnd, localInRepeat, lookAheadAtStart);\n            localChildren.reverse();\n            localPositions.reverse();\n            if (localInRepeat > -1 && lastGroup > 0) {\n                let make = makeBalanced(type);\n                node = balanceRange(type, localChildren, localPositions, 0, localChildren.length, 0, end - start, make, make);\n            }\n            else {\n                node = makeTree(type, localChildren, localPositions, end - start, lookAheadAtStart - end);\n            }\n        }\n        children.push(node);\n        positions.push(startPos);\n    }\n    function makeBalanced(type) {\n        return (children, positions, length) => {\n            let lookAhead = 0, lastI = children.length - 1, last, lookAheadProp;\n            if (lastI >= 0 && (last = children[lastI]) instanceof Tree) {\n                if (!lastI && last.type == type && last.length == length)\n                    return last;\n                if (lookAheadProp = last.prop(NodeProp.lookAhead))\n                    lookAhead = positions[lastI] + last.length + lookAheadProp;\n            }\n            return makeTree(type, children, positions, length, lookAhead);\n        };\n    }\n    function makeRepeatLeaf(children, positions, base, i, from, to, type, lookAhead) {\n        let localChildren = [], localPositions = [];\n        while (children.length > i) {\n            localChildren.push(children.pop());\n            localPositions.push(positions.pop() + base - from);\n        }\n        children.push(makeTree(nodeSet.types[type], localChildren, localPositions, to - from, lookAhead - to));\n        positions.push(from - base);\n    }\n    function makeTree(type, children, positions, length, lookAhead = 0, props) {\n        if (contextHash) {\n            let pair = [NodeProp.contextHash, contextHash];\n            props = props ? [pair].concat(props) : [pair];\n        }\n        if (lookAhead > 25) {\n            let pair = [NodeProp.lookAhead, lookAhead];\n            props = props ? [pair].concat(props) : [pair];\n        }\n        return new Tree(type, children, positions, length, props);\n    }\n    function findBufferSize(maxSize, inRepeat) {\n        // Scan through the buffer to find previous siblings that fit\n        // together in a TreeBuffer, and don't contain any reused nodes\n        // (which can't be stored in a buffer).\n        // If `inRepeat` is > -1, ignore node boundaries of that type for\n        // nesting, but make sure the end falls either at the start\n        // (`maxSize`) or before such a node.\n        let fork = cursor.fork();\n        let size = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength;\n        let result = { size: 0, start: 0, skip: 0 };\n        scan: for (let minPos = fork.pos - maxSize; fork.pos > minPos;) {\n            let nodeSize = fork.size;\n            // Pretend nested repeat nodes of the same type don't exist\n            if (fork.id == inRepeat && nodeSize >= 0) {\n                // Except that we store the current state as a valid return\n                // value.\n                result.size = size;\n                result.start = start;\n                result.skip = skip;\n                skip += 4;\n                size += 4;\n                fork.next();\n                continue;\n            }\n            let startPos = fork.pos - nodeSize;\n            if (nodeSize < 0 || startPos < minPos || fork.start < minStart)\n                break;\n            let localSkipped = fork.id >= minRepeatType ? 4 : 0;\n            let nodeStart = fork.start;\n            fork.next();\n            while (fork.pos > startPos) {\n                if (fork.size < 0) {\n                    if (fork.size == -3 /* ContextChange */)\n                        localSkipped += 4;\n                    else\n                        break scan;\n                }\n                else if (fork.id >= minRepeatType) {\n                    localSkipped += 4;\n                }\n                fork.next();\n            }\n            start = nodeStart;\n            size += nodeSize;\n            skip += localSkipped;\n        }\n        if (inRepeat < 0 || size == maxSize) {\n            result.size = size;\n            result.start = start;\n            result.skip = skip;\n        }\n        return result.size > 4 ? result : undefined;\n    }\n    function copyToBuffer(bufferStart, buffer, index) {\n        let { id, start, end, size } = cursor;\n        cursor.next();\n        if (size >= 0 && id < minRepeatType) {\n            let startIndex = index;\n            if (size > 4) {\n                let endPos = cursor.pos - (size - 4);\n                while (cursor.pos > endPos)\n                    index = copyToBuffer(bufferStart, buffer, index);\n            }\n            buffer[--index] = startIndex;\n            buffer[--index] = end - bufferStart;\n            buffer[--index] = start - bufferStart;\n            buffer[--index] = id;\n        }\n        else if (size == -3 /* ContextChange */) {\n            contextHash = id;\n        }\n        else if (size == -4 /* LookAhead */) {\n            lookAhead = id;\n        }\n        return index;\n    }\n    let children = [], positions = [];\n    while (cursor.pos > 0)\n        takeNode(data.start || 0, data.bufferStart || 0, children, positions, -1);\n    let length = (_a = data.length) !== null && _a !== void 0 ? _a : (children.length ? positions[0] + children[0].length : 0);\n    return new Tree(types[data.topID], children.reverse(), positions.reverse(), length);\n}\nconst nodeSizeCache = new WeakMap;\nfunction nodeSize(balanceType, node) {\n    if (!balanceType.isAnonymous || node instanceof TreeBuffer || node.type != balanceType)\n        return 1;\n    let size = nodeSizeCache.get(node);\n    if (size == null) {\n        size = 1;\n        for (let child of node.children) {\n            if (child.type != balanceType || !(child instanceof Tree)) {\n                size = 1;\n                break;\n            }\n            size += nodeSize(balanceType, child);\n        }\n        nodeSizeCache.set(node, size);\n    }\n    return size;\n}\nfunction balanceRange(\n// The type the balanced tree's inner nodes.\nbalanceType, \n// The direct children and their positions\nchildren, positions, \n// The index range in children/positions to use\nfrom, to, \n// The start position of the nodes, relative to their parent.\nstart, \n// Length of the outer node\nlength, \n// Function to build the top node of the balanced tree\nmkTop, \n// Function to build internal nodes for the balanced tree\nmkTree) {\n    let total = 0;\n    for (let i = from; i < to; i++)\n        total += nodeSize(balanceType, children[i]);\n    let maxChild = Math.ceil((total * 1.5) / 8 /* BranchFactor */);\n    let localChildren = [], localPositions = [];\n    function divide(children, positions, from, to, offset) {\n        for (let i = from; i < to;) {\n            let groupFrom = i, groupStart = positions[i], groupSize = nodeSize(balanceType, children[i]);\n            i++;\n            for (; i < to; i++) {\n                let nextSize = nodeSize(balanceType, children[i]);\n                if (groupSize + nextSize >= maxChild)\n                    break;\n                groupSize += nextSize;\n            }\n            if (i == groupFrom + 1) {\n                if (groupSize > maxChild) {\n                    let only = children[groupFrom]; // Only trees can have a size > 1\n                    divide(only.children, only.positions, 0, only.children.length, positions[groupFrom] + offset);\n                    continue;\n                }\n                localChildren.push(children[groupFrom]);\n            }\n            else {\n                let length = positions[i - 1] + children[i - 1].length - groupStart;\n                localChildren.push(balanceRange(balanceType, children, positions, groupFrom, i, groupStart, length, null, mkTree));\n            }\n            localPositions.push(groupStart + offset - start);\n        }\n    }\n    divide(children, positions, from, to, 0);\n    return (mkTop || mkTree)(localChildren, localPositions, length);\n}\n/// Provides a way to associate values with pieces of trees. As long\n/// as that part of the tree is reused, the associated values can be\n/// retrieved from an updated tree.\nclass NodeWeakMap {\n    constructor() {\n        this.map = new WeakMap();\n    }\n    setBuffer(buffer, index, value) {\n        let inner = this.map.get(buffer);\n        if (!inner)\n            this.map.set(buffer, inner = new Map);\n        inner.set(index, value);\n    }\n    getBuffer(buffer, index) {\n        let inner = this.map.get(buffer);\n        return inner && inner.get(index);\n    }\n    /// Set the value for this syntax node.\n    set(node, value) {\n        if (node instanceof BufferNode)\n            this.setBuffer(node.context.buffer, node.index, value);\n        else if (node instanceof TreeNode)\n            this.map.set(node.tree, value);\n    }\n    /// Retrieve value for this syntax node, if it exists in the map.\n    get(node) {\n        return node instanceof BufferNode ? this.getBuffer(node.context.buffer, node.index)\n            : node instanceof TreeNode ? this.map.get(node.tree) : undefined;\n    }\n    /// Set the value for the node that a cursor currently points to.\n    cursorSet(cursor, value) {\n        if (cursor.buffer)\n            this.setBuffer(cursor.buffer.buffer, cursor.index, value);\n        else\n            this.map.set(cursor.tree, value);\n    }\n    /// Retrieve the value for the node that a cursor currently points\n    /// to.\n    cursorGet(cursor) {\n        return cursor.buffer ? this.getBuffer(cursor.buffer.buffer, cursor.index) : this.map.get(cursor.tree);\n    }\n}\n\n/// Tree fragments are used during [incremental\n/// parsing](#common.Parser.startParse) to track parts of old trees\n/// that can be reused in a new parse. An array of fragments is used\n/// to track regions of an old tree whose nodes might be reused in new\n/// parses. Use the static\n/// [`applyChanges`](#common.TreeFragment^applyChanges) method to\n/// update fragments for document changes.\nclass TreeFragment {\n    /// Construct a tree fragment. You'll usually want to use\n    /// [`addTree`](#common.TreeFragment^addTree) and\n    /// [`applyChanges`](#common.TreeFragment^applyChanges) instead of\n    /// calling this directly.\n    constructor(\n    /// The start of the unchanged range pointed to by this fragment.\n    /// This refers to an offset in the _updated_ document (as opposed\n    /// to the original tree).\n    from, \n    /// The end of the unchanged range.\n    to, \n    /// The tree that this fragment is based on.\n    tree, \n    /// The offset between the fragment's tree and the document that\n    /// this fragment can be used against. Add this when going from\n    /// document to tree positions, subtract it to go from tree to\n    /// document positions.\n    offset, openStart = false, openEnd = false) {\n        this.from = from;\n        this.to = to;\n        this.tree = tree;\n        this.offset = offset;\n        this.open = (openStart ? 1 /* Start */ : 0) | (openEnd ? 2 /* End */ : 0);\n    }\n    /// Whether the start of the fragment represents the start of a\n    /// parse, or the end of a change. (In the second case, it may not\n    /// be safe to reuse some nodes at the start, depending on the\n    /// parsing algorithm.)\n    get openStart() { return (this.open & 1 /* Start */) > 0; }\n    /// Whether the end of the fragment represents the end of a\n    /// full-document parse, or the start of a change.\n    get openEnd() { return (this.open & 2 /* End */) > 0; }\n    /// Create a set of fragments from a freshly parsed tree, or update\n    /// an existing set of fragments by replacing the ones that overlap\n    /// with a tree with content from the new tree. When `partial` is\n    /// true, the parse is treated as incomplete, and the resulting\n    /// fragment has [`openEnd`](#common.TreeFragment.openEnd) set to\n    /// true.\n    static addTree(tree, fragments = [], partial = false) {\n        let result = [new TreeFragment(0, tree.length, tree, 0, false, partial)];\n        for (let f of fragments)\n            if (f.to > tree.length)\n                result.push(f);\n        return result;\n    }\n    /// Apply a set of edits to an array of fragments, removing or\n    /// splitting fragments as necessary to remove edited ranges, and\n    /// adjusting offsets for fragments that moved.\n    static applyChanges(fragments, changes, minGap = 128) {\n        if (!changes.length)\n            return fragments;\n        let result = [];\n        let fI = 1, nextF = fragments.length ? fragments[0] : null;\n        for (let cI = 0, pos = 0, off = 0;; cI++) {\n            let nextC = cI < changes.length ? changes[cI] : null;\n            let nextPos = nextC ? nextC.fromA : 1e9;\n            if (nextPos - pos >= minGap)\n                while (nextF && nextF.from < nextPos) {\n                    let cut = nextF;\n                    if (pos >= cut.from || nextPos <= cut.to || off) {\n                        let fFrom = Math.max(cut.from, pos) - off, fTo = Math.min(cut.to, nextPos) - off;\n                        cut = fFrom >= fTo ? null : new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, cI > 0, !!nextC);\n                    }\n                    if (cut)\n                        result.push(cut);\n                    if (nextF.to > nextPos)\n                        break;\n                    nextF = fI < fragments.length ? fragments[fI++] : null;\n                }\n            if (!nextC)\n                break;\n            pos = nextC.toA;\n            off = nextC.toA - nextC.toB;\n        }\n        return result;\n    }\n}\n/// A superclass that parsers should extend.\nclass Parser {\n    /// Start a parse, returning a [partial parse](#common.PartialParse)\n    /// object. [`fragments`](#common.TreeFragment) can be passed in to\n    /// make the parse incremental.\n    ///\n    /// By default, the entire input is parsed. You can pass `ranges`,\n    /// which should be a sorted array of non-empty, non-overlapping\n    /// ranges, to parse only those ranges. The tree returned in that\n    /// case will start at `ranges[0].from`.\n    startParse(input, fragments, ranges) {\n        if (typeof input == \"string\")\n            input = new StringInput(input);\n        ranges = !ranges ? [new Range(0, input.length)] : ranges.length ? ranges.map(r => new Range(r.from, r.to)) : [new Range(0, 0)];\n        return this.createParse(input, fragments || [], ranges);\n    }\n    /// Run a full parse, returning the resulting tree.\n    parse(input, fragments, ranges) {\n        let parse = this.startParse(input, fragments, ranges);\n        for (;;) {\n            let done = parse.advance();\n            if (done)\n                return done;\n        }\n    }\n}\nclass StringInput {\n    constructor(string) {\n        this.string = string;\n    }\n    get length() { return this.string.length; }\n    chunk(from) { return this.string.slice(from); }\n    get lineChunks() { return false; }\n    read(from, to) { return this.string.slice(from, to); }\n}\n\n/// Create a parse wrapper that, after the inner parse completes,\n/// scans its tree for mixed language regions with the `nest`\n/// function, runs the resulting [inner parses](#common.NestedParse),\n/// and then [mounts](#common.NodeProp^mounted) their results onto the\n/// tree.\nfunction parseMixed(nest) {\n    return (parse, input, fragments, ranges) => new MixedParse(parse, nest, input, fragments, ranges);\n}\nclass InnerParse {\n    constructor(parser, parse, overlay, target, ranges) {\n        this.parser = parser;\n        this.parse = parse;\n        this.overlay = overlay;\n        this.target = target;\n        this.ranges = ranges;\n    }\n}\nclass ActiveOverlay {\n    constructor(parser, predicate, mounts, index, start, target, prev) {\n        this.parser = parser;\n        this.predicate = predicate;\n        this.mounts = mounts;\n        this.index = index;\n        this.start = start;\n        this.target = target;\n        this.prev = prev;\n        this.depth = 0;\n        this.ranges = [];\n    }\n}\nconst stoppedInner = new NodeProp({ perNode: true });\nclass MixedParse {\n    constructor(base, nest, input, fragments, ranges) {\n        this.nest = nest;\n        this.input = input;\n        this.fragments = fragments;\n        this.ranges = ranges;\n        this.inner = [];\n        this.innerDone = 0;\n        this.baseTree = null;\n        this.stoppedAt = null;\n        this.baseParse = base;\n    }\n    advance() {\n        if (this.baseParse) {\n            let done = this.baseParse.advance();\n            if (!done)\n                return null;\n            this.baseParse = null;\n            this.baseTree = done;\n            this.startInner();\n            if (this.stoppedAt != null)\n                for (let inner of this.inner)\n                    inner.parse.stopAt(this.stoppedAt);\n        }\n        if (this.innerDone == this.inner.length) {\n            let result = this.baseTree;\n            if (this.stoppedAt != null)\n                result = new Tree(result.type, result.children, result.positions, result.length, result.propValues.concat([[stoppedInner, this.stoppedAt]]));\n            return result;\n        }\n        let inner = this.inner[this.innerDone], done = inner.parse.advance();\n        if (done) {\n            this.innerDone++;\n            // This is a somewhat dodgy but super helpful hack where we\n            // patch up nodes created by the inner parse (and thus\n            // presumably not aliased anywhere else) to hold the information\n            // about the inner parse.\n            let props = Object.assign(Object.create(null), inner.target.props);\n            props[NodeProp.mounted.id] = new MountedTree(done, inner.overlay, inner.parser);\n            inner.target.props = props;\n        }\n        return null;\n    }\n    get parsedPos() {\n        if (this.baseParse)\n            return 0;\n        let pos = this.input.length;\n        for (let i = this.innerDone; i < this.inner.length; i++) {\n            if (this.inner[i].ranges[0].from < pos)\n                pos = Math.min(pos, this.inner[i].parse.parsedPos);\n        }\n        return pos;\n    }\n    stopAt(pos) {\n        this.stoppedAt = pos;\n        if (this.baseParse)\n            this.baseParse.stopAt(pos);\n        else\n            for (let i = this.innerDone; i < this.inner.length; i++)\n                this.inner[i].parse.stopAt(pos);\n    }\n    startInner() {\n        let fragmentCursor = new FragmentCursor(this.fragments);\n        let overlay = null;\n        let covered = null;\n        let cursor = new TreeCursor(new TreeNode(this.baseTree, this.ranges[0].from, 0, null), IterMode.IncludeAnonymous | IterMode.IgnoreMounts);\n        scan: for (let nest, isCovered; this.stoppedAt == null || cursor.from < this.stoppedAt;) {\n            let enter = true, range;\n            if (fragmentCursor.hasNode(cursor)) {\n                if (overlay) {\n                    let match = overlay.mounts.find(m => m.frag.from <= cursor.from && m.frag.to >= cursor.to && m.mount.overlay);\n                    if (match)\n                        for (let r of match.mount.overlay) {\n                            let from = r.from + match.pos, to = r.to + match.pos;\n                            if (from >= cursor.from && to <= cursor.to && !overlay.ranges.some(r => r.from < to && r.to > from))\n                                overlay.ranges.push({ from, to });\n                        }\n                }\n                enter = false;\n            }\n            else if (covered && (isCovered = checkCover(covered.ranges, cursor.from, cursor.to))) {\n                enter = isCovered != 2 /* Full */;\n            }\n            else if (!cursor.type.isAnonymous && cursor.from < cursor.to && (nest = this.nest(cursor, this.input))) {\n                if (!cursor.tree)\n                    materialize(cursor);\n                let oldMounts = fragmentCursor.findMounts(cursor.from, nest.parser);\n                if (typeof nest.overlay == \"function\") {\n                    overlay = new ActiveOverlay(nest.parser, nest.overlay, oldMounts, this.inner.length, cursor.from, cursor.tree, overlay);\n                }\n                else {\n                    let ranges = punchRanges(this.ranges, nest.overlay || [new Range(cursor.from, cursor.to)]);\n                    if (ranges.length)\n                        this.inner.push(new InnerParse(nest.parser, nest.parser.startParse(this.input, enterFragments(oldMounts, ranges), ranges), nest.overlay ? nest.overlay.map(r => new Range(r.from - cursor.from, r.to - cursor.from)) : null, cursor.tree, ranges));\n                    if (!nest.overlay)\n                        enter = false;\n                    else if (ranges.length)\n                        covered = { ranges, depth: 0, prev: covered };\n                }\n            }\n            else if (overlay && (range = overlay.predicate(cursor))) {\n                if (range === true)\n                    range = new Range(cursor.from, cursor.to);\n                if (range.from < range.to)\n                    overlay.ranges.push(range);\n            }\n            if (enter && cursor.firstChild()) {\n                if (overlay)\n                    overlay.depth++;\n                if (covered)\n                    covered.depth++;\n            }\n            else {\n                for (;;) {\n                    if (cursor.nextSibling())\n                        break;\n                    if (!cursor.parent())\n                        break scan;\n                    if (overlay && !--overlay.depth) {\n                        let ranges = punchRanges(this.ranges, overlay.ranges);\n                        if (ranges.length)\n                            this.inner.splice(overlay.index, 0, new InnerParse(overlay.parser, overlay.parser.startParse(this.input, enterFragments(overlay.mounts, ranges), ranges), overlay.ranges.map(r => new Range(r.from - overlay.start, r.to - overlay.start)), overlay.target, ranges));\n                        overlay = overlay.prev;\n                    }\n                    if (covered && !--covered.depth)\n                        covered = covered.prev;\n                }\n            }\n        }\n    }\n}\nfunction checkCover(covered, from, to) {\n    for (let range of covered) {\n        if (range.from >= to)\n            break;\n        if (range.to > from)\n            return range.from <= from && range.to >= to ? 2 /* Full */ : 1 /* Partial */;\n    }\n    return 0 /* None */;\n}\n// Take a piece of buffer and convert it into a stand-alone\n// TreeBuffer.\nfunction sliceBuf(buf, startI, endI, nodes, positions, off) {\n    if (startI < endI) {\n        let from = buf.buffer[startI + 1], to = buf.buffer[endI - 2];\n        nodes.push(buf.slice(startI, endI, from, to));\n        positions.push(from - off);\n    }\n}\n// This function takes a node that's in a buffer, and converts it, and\n// its parent buffer nodes, into a Tree. This is again acting on the\n// assumption that the trees and buffers have been constructed by the\n// parse that was ran via the mix parser, and thus aren't shared with\n// any other code, making violations of the immutability safe.\nfunction materialize(cursor) {\n    let { node } = cursor, depth = 0;\n    // Scan up to the nearest tree\n    do {\n        cursor.parent();\n        depth++;\n    } while (!cursor.tree);\n    // Find the index of the buffer in that tree\n    let i = 0, base = cursor.tree, off = 0;\n    for (;; i++) {\n        off = base.positions[i] + cursor.from;\n        if (off <= node.from && off + base.children[i].length >= node.to)\n            break;\n    }\n    let buf = base.children[i], b = buf.buffer;\n    // Split a level in the buffer, putting the nodes before and after\n    // the child that contains `node` into new buffers.\n    function split(startI, endI, type, innerOffset, length) {\n        let i = startI;\n        while (b[i + 2] + off <= node.from)\n            i = b[i + 3];\n        let children = [], positions = [];\n        sliceBuf(buf, startI, i, children, positions, innerOffset);\n        let from = b[i + 1], to = b[i + 2];\n        let isTarget = from + off == node.from && to + off == node.to && b[i] == node.type.id;\n        children.push(isTarget ? node.toTree() : split(i + 4, b[i + 3], buf.set.types[b[i]], from, to - from));\n        positions.push(from - innerOffset);\n        sliceBuf(buf, b[i + 3], endI, children, positions, innerOffset);\n        return new Tree(type, children, positions, length);\n    }\n    base.children[i] = split(0, b.length, NodeType.none, 0, buf.length);\n    // Move the cursor back to the target node\n    for (let d = 0; d <= depth; d++)\n        cursor.childAfter(node.from);\n}\nclass StructureCursor {\n    constructor(root, offset) {\n        this.offset = offset;\n        this.done = false;\n        this.cursor = root.cursor(IterMode.IncludeAnonymous | IterMode.IgnoreMounts);\n    }\n    // Move to the first node (in pre-order) that starts at or after `pos`.\n    moveTo(pos) {\n        let { cursor } = this, p = pos - this.offset;\n        while (!this.done && cursor.from < p) {\n            if (cursor.to >= pos && cursor.enter(p, 1, IterMode.IgnoreOverlays | IterMode.ExcludeBuffers)) ;\n            else if (!cursor.next(false))\n                this.done = true;\n        }\n    }\n    hasNode(cursor) {\n        this.moveTo(cursor.from);\n        if (!this.done && this.cursor.from + this.offset == cursor.from && this.cursor.tree) {\n            for (let tree = this.cursor.tree;;) {\n                if (tree == cursor.tree)\n                    return true;\n                if (tree.children.length && tree.positions[0] == 0 && tree.children[0] instanceof Tree)\n                    tree = tree.children[0];\n                else\n                    break;\n            }\n        }\n        return false;\n    }\n}\nclass FragmentCursor {\n    constructor(fragments) {\n        var _a;\n        this.fragments = fragments;\n        this.curTo = 0;\n        this.fragI = 0;\n        if (fragments.length) {\n            let first = this.curFrag = fragments[0];\n            this.curTo = (_a = first.tree.prop(stoppedInner)) !== null && _a !== void 0 ? _a : first.to;\n            this.inner = new StructureCursor(first.tree, -first.offset);\n        }\n        else {\n            this.curFrag = this.inner = null;\n        }\n    }\n    hasNode(node) {\n        while (this.curFrag && node.from >= this.curTo)\n            this.nextFrag();\n        return this.curFrag && this.curFrag.from <= node.from && this.curTo >= node.to && this.inner.hasNode(node);\n    }\n    nextFrag() {\n        var _a;\n        this.fragI++;\n        if (this.fragI == this.fragments.length) {\n            this.curFrag = this.inner = null;\n        }\n        else {\n            let frag = this.curFrag = this.fragments[this.fragI];\n            this.curTo = (_a = frag.tree.prop(stoppedInner)) !== null && _a !== void 0 ? _a : frag.to;\n            this.inner = new StructureCursor(frag.tree, -frag.offset);\n        }\n    }\n    findMounts(pos, parser) {\n        var _a;\n        let result = [];\n        if (this.inner) {\n            this.inner.cursor.moveTo(pos, 1);\n            for (let pos = this.inner.cursor.node; pos; pos = pos.parent) {\n                let mount = (_a = pos.tree) === null || _a === void 0 ? void 0 : _a.prop(NodeProp.mounted);\n                if (mount && mount.parser == parser) {\n                    for (let i = this.fragI; i < this.fragments.length; i++) {\n                        let frag = this.fragments[i];\n                        if (frag.from >= pos.to)\n                            break;\n                        if (frag.tree == this.curFrag.tree)\n                            result.push({\n                                frag,\n                                pos: pos.from - frag.offset,\n                                mount\n                            });\n                    }\n                }\n            }\n        }\n        return result;\n    }\n}\nfunction punchRanges(outer, ranges) {\n    let copy = null, current = ranges;\n    for (let i = 1, j = 0; i < outer.length; i++) {\n        let gapFrom = outer[i - 1].to, gapTo = outer[i].from;\n        for (; j < current.length; j++) {\n            let r = current[j];\n            if (r.from >= gapTo)\n                break;\n            if (r.to <= gapFrom)\n                continue;\n            if (!copy)\n                current = copy = ranges.slice();\n            if (r.from < gapFrom) {\n                copy[j] = new Range(r.from, gapFrom);\n                if (r.to > gapTo)\n                    copy.splice(j + 1, 0, new Range(gapTo, r.to));\n            }\n            else if (r.to > gapTo) {\n                copy[j--] = new Range(gapTo, r.to);\n            }\n            else {\n                copy.splice(j--, 1);\n            }\n        }\n    }\n    return current;\n}\nfunction findCoverChanges(a, b, from, to) {\n    let iA = 0, iB = 0, inA = false, inB = false, pos = -1e9;\n    let result = [];\n    for (;;) {\n        let nextA = iA == a.length ? 1e9 : inA ? a[iA].to : a[iA].from;\n        let nextB = iB == b.length ? 1e9 : inB ? b[iB].to : b[iB].from;\n        if (inA != inB) {\n            let start = Math.max(pos, from), end = Math.min(nextA, nextB, to);\n            if (start < end)\n                result.push(new Range(start, end));\n        }\n        pos = Math.min(nextA, nextB);\n        if (pos == 1e9)\n            break;\n        if (nextA == pos) {\n            if (!inA)\n                inA = true;\n            else {\n                inA = false;\n                iA++;\n            }\n        }\n        if (nextB == pos) {\n            if (!inB)\n                inB = true;\n            else {\n                inB = false;\n                iB++;\n            }\n        }\n    }\n    return result;\n}\n// Given a number of fragments for the outer tree, and a set of ranges\n// to parse, find fragments for inner trees mounted around those\n// ranges, if any.\nfunction enterFragments(mounts, ranges) {\n    let result = [];\n    for (let { pos, mount, frag } of mounts) {\n        let startPos = pos + (mount.overlay ? mount.overlay[0].from : 0), endPos = startPos + mount.tree.length;\n        let from = Math.max(frag.from, startPos), to = Math.min(frag.to, endPos);\n        if (mount.overlay) {\n            let overlay = mount.overlay.map(r => new Range(r.from + pos, r.to + pos));\n            let changes = findCoverChanges(ranges, overlay, from, to);\n            for (let i = 0, pos = from;; i++) {\n                let last = i == changes.length, end = last ? to : changes[i].from;\n                if (end > pos)\n                    result.push(new TreeFragment(pos, end, mount.tree, -startPos, frag.from >= pos || frag.openStart, frag.to <= end || frag.openEnd));\n                if (last)\n                    break;\n                pos = changes[i].to;\n            }\n        }\n        else {\n            result.push(new TreeFragment(from, to, mount.tree, -startPos, frag.from >= startPos || frag.openStart, frag.to <= endPos || frag.openEnd));\n        }\n    }\n    return result;\n}\n\nexport { DefaultBufferLength, IterMode, MountedTree, NodeProp, NodeSet, NodeType, NodeWeakMap, Parser, Tree, TreeBuffer, TreeCursor, TreeFragment, parseMixed };\n", "import { Parser, NodeSet, NodeType, DefaultBufferLength, NodeProp, Tree, IterMode } from '@lezer/common';\n\n/// A parse stack. These are used internally by the parser to track\n/// parsing progress. They also provide some properties and methods\n/// that external code such as a tokenizer can use to get information\n/// about the parse state.\nclass Stack {\n    /// @internal\n    constructor(\n    /// The parse that this stack is part of @internal\n    p, \n    /// Holds state, input pos, buffer index triplets for all but the\n    /// top state @internal\n    stack, \n    /// The current parse state @internal\n    state, \n    // The position at which the next reduce should take place. This\n    // can be less than `this.pos` when skipped expressions have been\n    // added to the stack (which should be moved outside of the next\n    // reduction)\n    /// @internal\n    reducePos, \n    /// The input position up to which this stack has parsed.\n    pos, \n    /// The dynamic score of the stack, including dynamic precedence\n    /// and error-recovery penalties\n    /// @internal\n    score, \n    // The output buffer. Holds (type, start, end, size) quads\n    // representing nodes created by the parser, where `size` is\n    // amount of buffer array entries covered by this node.\n    /// @internal\n    buffer, \n    // The base offset of the buffer. When stacks are split, the split\n    // instance shared the buffer history with its parent up to\n    // `bufferBase`, which is the absolute offset (including the\n    // offset of previous splits) into the buffer at which this stack\n    // starts writing.\n    /// @internal\n    bufferBase, \n    /// @internal\n    curContext, \n    /// @internal\n    lookAhead = 0, \n    // A parent stack from which this was split off, if any. This is\n    // set up so that it always points to a stack that has some\n    // additional buffer content, never to a stack with an equal\n    // `bufferBase`.\n    /// @internal\n    parent) {\n        this.p = p;\n        this.stack = stack;\n        this.state = state;\n        this.reducePos = reducePos;\n        this.pos = pos;\n        this.score = score;\n        this.buffer = buffer;\n        this.bufferBase = bufferBase;\n        this.curContext = curContext;\n        this.lookAhead = lookAhead;\n        this.parent = parent;\n    }\n    /// @internal\n    toString() {\n        return `[${this.stack.filter((_, i) => i % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? \"!\" + this.score : \"\"}`;\n    }\n    // Start an empty stack\n    /// @internal\n    static start(p, state, pos = 0) {\n        let cx = p.parser.context;\n        return new Stack(p, [], state, pos, pos, 0, [], 0, cx ? new StackContext(cx, cx.start) : null, 0, null);\n    }\n    /// The stack's current [context](#lr.ContextTracker) value, if\n    /// any. Its type will depend on the context tracker's type\n    /// parameter, or it will be `null` if there is no context\n    /// tracker.\n    get context() { return this.curContext ? this.curContext.context : null; }\n    // Push a state onto the stack, tracking its start position as well\n    // as the buffer base at that point.\n    /// @internal\n    pushState(state, start) {\n        this.stack.push(this.state, start, this.bufferBase + this.buffer.length);\n        this.state = state;\n    }\n    // Apply a reduce action\n    /// @internal\n    reduce(action) {\n        let depth = action >> 19 /* ReduceDepthShift */, type = action & 65535 /* ValueMask */;\n        let { parser } = this.p;\n        let dPrec = parser.dynamicPrecedence(type);\n        if (dPrec)\n            this.score += dPrec;\n        if (depth == 0) {\n            this.pushState(parser.getGoto(this.state, type, true), this.reducePos);\n            // Zero-depth reductions are a special case\u2014they add stuff to\n            // the stack without popping anything off.\n            if (type < parser.minRepeatTerm)\n                this.storeNode(type, this.reducePos, this.reducePos, 4, true);\n            this.reduceContext(type, this.reducePos);\n            return;\n        }\n        // Find the base index into `this.stack`, content after which will\n        // be dropped. Note that with `StayFlag` reductions we need to\n        // consume two extra frames (the dummy parent node for the skipped\n        // expression and the state that we'll be staying in, which should\n        // be moved to `this.state`).\n        let base = this.stack.length - ((depth - 1) * 3) - (action & 262144 /* StayFlag */ ? 6 : 0);\n        let start = this.stack[base - 2];\n        let bufferBase = this.stack[base - 1], count = this.bufferBase + this.buffer.length - bufferBase;\n        // Store normal terms or `R -> R R` repeat reductions\n        if (type < parser.minRepeatTerm || (action & 131072 /* RepeatFlag */)) {\n            let pos = parser.stateFlag(this.state, 1 /* Skipped */) ? this.pos : this.reducePos;\n            this.storeNode(type, start, pos, count + 4, true);\n        }\n        if (action & 262144 /* StayFlag */) {\n            this.state = this.stack[base];\n        }\n        else {\n            let baseStateID = this.stack[base - 3];\n            this.state = parser.getGoto(baseStateID, type, true);\n        }\n        while (this.stack.length > base)\n            this.stack.pop();\n        this.reduceContext(type, start);\n    }\n    // Shift a value into the buffer\n    /// @internal\n    storeNode(term, start, end, size = 4, isReduce = false) {\n        if (term == 0 /* Err */ &&\n            (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {\n            // Try to omit/merge adjacent error nodes\n            let cur = this, top = this.buffer.length;\n            if (top == 0 && cur.parent) {\n                top = cur.bufferBase - cur.parent.bufferBase;\n                cur = cur.parent;\n            }\n            if (top > 0 && cur.buffer[top - 4] == 0 /* Err */ && cur.buffer[top - 1] > -1) {\n                if (start == end)\n                    return;\n                if (cur.buffer[top - 2] >= start) {\n                    cur.buffer[top - 2] = end;\n                    return;\n                }\n            }\n        }\n        if (!isReduce || this.pos == end) { // Simple case, just append\n            this.buffer.push(term, start, end, size);\n        }\n        else { // There may be skipped nodes that have to be moved forward\n            let index = this.buffer.length;\n            if (index > 0 && this.buffer[index - 4] != 0 /* Err */)\n                while (index > 0 && this.buffer[index - 2] > end) {\n                    // Move this record forward\n                    this.buffer[index] = this.buffer[index - 4];\n                    this.buffer[index + 1] = this.buffer[index - 3];\n                    this.buffer[index + 2] = this.buffer[index - 2];\n                    this.buffer[index + 3] = this.buffer[index - 1];\n                    index -= 4;\n                    if (size > 4)\n                        size -= 4;\n                }\n            this.buffer[index] = term;\n            this.buffer[index + 1] = start;\n            this.buffer[index + 2] = end;\n            this.buffer[index + 3] = size;\n        }\n    }\n    // Apply a shift action\n    /// @internal\n    shift(action, next, nextEnd) {\n        let start = this.pos;\n        if (action & 131072 /* GotoFlag */) {\n            this.pushState(action & 65535 /* ValueMask */, this.pos);\n        }\n        else if ((action & 262144 /* StayFlag */) == 0) { // Regular shift\n            let nextState = action, { parser } = this.p;\n            if (nextEnd > this.pos || next <= parser.maxNode) {\n                this.pos = nextEnd;\n                if (!parser.stateFlag(nextState, 1 /* Skipped */))\n                    this.reducePos = nextEnd;\n            }\n            this.pushState(nextState, start);\n            this.shiftContext(next, start);\n            if (next <= parser.maxNode)\n                this.buffer.push(next, start, nextEnd, 4);\n        }\n        else { // Shift-and-stay, which means this is a skipped token\n            this.pos = nextEnd;\n            this.shiftContext(next, start);\n            if (next <= this.p.parser.maxNode)\n                this.buffer.push(next, start, nextEnd, 4);\n        }\n    }\n    // Apply an action\n    /// @internal\n    apply(action, next, nextEnd) {\n        if (action & 65536 /* ReduceFlag */)\n            this.reduce(action);\n        else\n            this.shift(action, next, nextEnd);\n    }\n    // Add a prebuilt (reused) node into the buffer.\n    /// @internal\n    useNode(value, next) {\n        let index = this.p.reused.length - 1;\n        if (index < 0 || this.p.reused[index] != value) {\n            this.p.reused.push(value);\n            index++;\n        }\n        let start = this.pos;\n        this.reducePos = this.pos = start + value.length;\n        this.pushState(next, start);\n        this.buffer.push(index, start, this.reducePos, -1 /* size == -1 means this is a reused value */);\n        if (this.curContext)\n            this.updateContext(this.curContext.tracker.reuse(this.curContext.context, value, this, this.p.stream.reset(this.pos - value.length)));\n    }\n    // Split the stack. Due to the buffer sharing and the fact\n    // that `this.stack` tends to stay quite shallow, this isn't very\n    // expensive.\n    /// @internal\n    split() {\n        let parent = this;\n        let off = parent.buffer.length;\n        // Because the top of the buffer (after this.pos) may be mutated\n        // to reorder reductions and skipped tokens, and shared buffers\n        // should be immutable, this copies any outstanding skipped tokens\n        // to the new buffer, and puts the base pointer before them.\n        while (off > 0 && parent.buffer[off - 2] > parent.reducePos)\n            off -= 4;\n        let buffer = parent.buffer.slice(off), base = parent.bufferBase + off;\n        // Make sure parent points to an actual parent with content, if there is such a parent.\n        while (parent && base == parent.bufferBase)\n            parent = parent.parent;\n        return new Stack(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, buffer, base, this.curContext, this.lookAhead, parent);\n    }\n    // Try to recover from an error by 'deleting' (ignoring) one token.\n    /// @internal\n    recoverByDelete(next, nextEnd) {\n        let isNode = next <= this.p.parser.maxNode;\n        if (isNode)\n            this.storeNode(next, this.pos, nextEnd, 4);\n        this.storeNode(0 /* Err */, this.pos, nextEnd, isNode ? 8 : 4);\n        this.pos = this.reducePos = nextEnd;\n        this.score -= 190 /* Delete */;\n    }\n    /// Check if the given term would be able to be shifted (optionally\n    /// after some reductions) on this stack. This can be useful for\n    /// external tokenizers that want to make sure they only provide a\n    /// given token when it applies.\n    canShift(term) {\n        for (let sim = new SimulatedStack(this);;) {\n            let action = this.p.parser.stateSlot(sim.state, 4 /* DefaultReduce */) || this.p.parser.hasAction(sim.state, term);\n            if ((action & 65536 /* ReduceFlag */) == 0)\n                return true;\n            if (action == 0)\n                return false;\n            sim.reduce(action);\n        }\n    }\n    // Apply up to Recover.MaxNext recovery actions that conceptually\n    // inserts some missing token or rule.\n    /// @internal\n    recoverByInsert(next) {\n        if (this.stack.length >= 300 /* MaxInsertStackDepth */)\n            return [];\n        let nextStates = this.p.parser.nextStates(this.state);\n        if (nextStates.length > 4 /* MaxNext */ << 1 || this.stack.length >= 120 /* DampenInsertStackDepth */) {\n            let best = [];\n            for (let i = 0, s; i < nextStates.length; i += 2) {\n                if ((s = nextStates[i + 1]) != this.state && this.p.parser.hasAction(s, next))\n                    best.push(nextStates[i], s);\n            }\n            if (this.stack.length < 120 /* DampenInsertStackDepth */)\n                for (let i = 0; best.length < 4 /* MaxNext */ << 1 && i < nextStates.length; i += 2) {\n                    let s = nextStates[i + 1];\n                    if (!best.some((v, i) => (i & 1) && v == s))\n                        best.push(nextStates[i], s);\n                }\n            nextStates = best;\n        }\n        let result = [];\n        for (let i = 0; i < nextStates.length && result.length < 4 /* MaxNext */; i += 2) {\n            let s = nextStates[i + 1];\n            if (s == this.state)\n                continue;\n            let stack = this.split();\n            stack.pushState(s, this.pos);\n            stack.storeNode(0 /* Err */, stack.pos, stack.pos, 4, true);\n            stack.shiftContext(nextStates[i], this.pos);\n            stack.score -= 200 /* Insert */;\n            result.push(stack);\n        }\n        return result;\n    }\n    // Force a reduce, if possible. Return false if that can't\n    // be done.\n    /// @internal\n    forceReduce() {\n        let reduce = this.p.parser.stateSlot(this.state, 5 /* ForcedReduce */);\n        if ((reduce & 65536 /* ReduceFlag */) == 0)\n            return false;\n        let { parser } = this.p;\n        if (!parser.validAction(this.state, reduce)) {\n            let depth = reduce >> 19 /* ReduceDepthShift */, term = reduce & 65535 /* ValueMask */;\n            let target = this.stack.length - depth * 3;\n            if (target < 0 || parser.getGoto(this.stack[target], term, false) < 0)\n                return false;\n            this.storeNode(0 /* Err */, this.reducePos, this.reducePos, 4, true);\n            this.score -= 100 /* Reduce */;\n        }\n        this.reducePos = this.pos;\n        this.reduce(reduce);\n        return true;\n    }\n    /// @internal\n    forceAll() {\n        while (!this.p.parser.stateFlag(this.state, 2 /* Accepting */)) {\n            if (!this.forceReduce()) {\n                this.storeNode(0 /* Err */, this.pos, this.pos, 4, true);\n                break;\n            }\n        }\n        return this;\n    }\n    /// Check whether this state has no further actions (assumed to be a direct descendant of the\n    /// top state, since any other states must be able to continue\n    /// somehow). @internal\n    get deadEnd() {\n        if (this.stack.length != 3)\n            return false;\n        let { parser } = this.p;\n        return parser.data[parser.stateSlot(this.state, 1 /* Actions */)] == 65535 /* End */ &&\n            !parser.stateSlot(this.state, 4 /* DefaultReduce */);\n    }\n    /// Restart the stack (put it back in its start state). Only safe\n    /// when this.stack.length == 3 (state is directly below the top\n    /// state). @internal\n    restart() {\n        this.state = this.stack[0];\n        this.stack.length = 0;\n    }\n    /// @internal\n    sameState(other) {\n        if (this.state != other.state || this.stack.length != other.stack.length)\n            return false;\n        for (let i = 0; i < this.stack.length; i += 3)\n            if (this.stack[i] != other.stack[i])\n                return false;\n        return true;\n    }\n    /// Get the parser used by this stack.\n    get parser() { return this.p.parser; }\n    /// Test whether a given dialect (by numeric ID, as exported from\n    /// the terms file) is enabled.\n    dialectEnabled(dialectID) { return this.p.parser.dialect.flags[dialectID]; }\n    shiftContext(term, start) {\n        if (this.curContext)\n            this.updateContext(this.curContext.tracker.shift(this.curContext.context, term, this, this.p.stream.reset(start)));\n    }\n    reduceContext(term, start) {\n        if (this.curContext)\n            this.updateContext(this.curContext.tracker.reduce(this.curContext.context, term, this, this.p.stream.reset(start)));\n    }\n    /// @internal\n    emitContext() {\n        let last = this.buffer.length - 1;\n        if (last < 0 || this.buffer[last] != -3)\n            this.buffer.push(this.curContext.hash, this.reducePos, this.reducePos, -3);\n    }\n    /// @internal\n    emitLookAhead() {\n        let last = this.buffer.length - 1;\n        if (last < 0 || this.buffer[last] != -4)\n            this.buffer.push(this.lookAhead, this.reducePos, this.reducePos, -4);\n    }\n    updateContext(context) {\n        if (context != this.curContext.context) {\n            let newCx = new StackContext(this.curContext.tracker, context);\n            if (newCx.hash != this.curContext.hash)\n                this.emitContext();\n            this.curContext = newCx;\n        }\n    }\n    /// @internal\n    setLookAhead(lookAhead) {\n        if (lookAhead > this.lookAhead) {\n            this.emitLookAhead();\n            this.lookAhead = lookAhead;\n        }\n    }\n    /// @internal\n    close() {\n        if (this.curContext && this.curContext.tracker.strict)\n            this.emitContext();\n        if (this.lookAhead > 0)\n            this.emitLookAhead();\n    }\n}\nclass StackContext {\n    constructor(tracker, context) {\n        this.tracker = tracker;\n        this.context = context;\n        this.hash = tracker.strict ? tracker.hash(context) : 0;\n    }\n}\nvar Recover;\n(function (Recover) {\n    Recover[Recover[\"Insert\"] = 200] = \"Insert\";\n    Recover[Recover[\"Delete\"] = 190] = \"Delete\";\n    Recover[Recover[\"Reduce\"] = 100] = \"Reduce\";\n    Recover[Recover[\"MaxNext\"] = 4] = \"MaxNext\";\n    Recover[Recover[\"MaxInsertStackDepth\"] = 300] = \"MaxInsertStackDepth\";\n    Recover[Recover[\"DampenInsertStackDepth\"] = 120] = \"DampenInsertStackDepth\";\n})(Recover || (Recover = {}));\n// Used to cheaply run some reductions to scan ahead without mutating\n// an entire stack\nclass SimulatedStack {\n    constructor(start) {\n        this.start = start;\n        this.state = start.state;\n        this.stack = start.stack;\n        this.base = this.stack.length;\n    }\n    reduce(action) {\n        let term = action & 65535 /* ValueMask */, depth = action >> 19 /* ReduceDepthShift */;\n        if (depth == 0) {\n            if (this.stack == this.start.stack)\n                this.stack = this.stack.slice();\n            this.stack.push(this.state, 0, 0);\n            this.base += 3;\n        }\n        else {\n            this.base -= (depth - 1) * 3;\n        }\n        let goto = this.start.p.parser.getGoto(this.stack[this.base - 3], term, true);\n        this.state = goto;\n    }\n}\n// This is given to `Tree.build` to build a buffer, and encapsulates\n// the parent-stack-walking necessary to read the nodes.\nclass StackBufferCursor {\n    constructor(stack, pos, index) {\n        this.stack = stack;\n        this.pos = pos;\n        this.index = index;\n        this.buffer = stack.buffer;\n        if (this.index == 0)\n            this.maybeNext();\n    }\n    static create(stack, pos = stack.bufferBase + stack.buffer.length) {\n        return new StackBufferCursor(stack, pos, pos - stack.bufferBase);\n    }\n    maybeNext() {\n        let next = this.stack.parent;\n        if (next != null) {\n            this.index = this.stack.bufferBase - next.bufferBase;\n            this.stack = next;\n            this.buffer = next.buffer;\n        }\n    }\n    get id() { return this.buffer[this.index - 4]; }\n    get start() { return this.buffer[this.index - 3]; }\n    get end() { return this.buffer[this.index - 2]; }\n    get size() { return this.buffer[this.index - 1]; }\n    next() {\n        this.index -= 4;\n        this.pos -= 4;\n        if (this.index == 0)\n            this.maybeNext();\n    }\n    fork() {\n        return new StackBufferCursor(this.stack, this.pos, this.index);\n    }\n}\n\nclass CachedToken {\n    constructor() {\n        this.start = -1;\n        this.value = -1;\n        this.end = -1;\n        this.extended = -1;\n        this.lookAhead = 0;\n        this.mask = 0;\n        this.context = 0;\n    }\n}\nconst nullToken = new CachedToken;\n/// [Tokenizers](#lr.ExternalTokenizer) interact with the input\n/// through this interface. It presents the input as a stream of\n/// characters, tracking lookahead and hiding the complexity of\n/// [ranges](#common.Parser.parse^ranges) from tokenizer code.\nclass InputStream {\n    /// @internal\n    constructor(\n    /// @internal\n    input, \n    /// @internal\n    ranges) {\n        this.input = input;\n        this.ranges = ranges;\n        /// @internal\n        this.chunk = \"\";\n        /// @internal\n        this.chunkOff = 0;\n        /// Backup chunk\n        this.chunk2 = \"\";\n        this.chunk2Pos = 0;\n        /// The character code of the next code unit in the input, or -1\n        /// when the stream is at the end of the input.\n        this.next = -1;\n        /// @internal\n        this.token = nullToken;\n        this.rangeIndex = 0;\n        this.pos = this.chunkPos = ranges[0].from;\n        this.range = ranges[0];\n        this.end = ranges[ranges.length - 1].to;\n        this.readNext();\n    }\n    /// @internal\n    resolveOffset(offset, assoc) {\n        let range = this.range, index = this.rangeIndex;\n        let pos = this.pos + offset;\n        while (pos < range.from) {\n            if (!index)\n                return null;\n            let next = this.ranges[--index];\n            pos -= range.from - next.to;\n            range = next;\n        }\n        while (assoc < 0 ? pos > range.to : pos >= range.to) {\n            if (index == this.ranges.length - 1)\n                return null;\n            let next = this.ranges[++index];\n            pos += next.from - range.to;\n            range = next;\n        }\n        return pos;\n    }\n    /// @internal\n    clipPos(pos) {\n        if (pos >= this.range.from && pos < this.range.to)\n            return pos;\n        for (let range of this.ranges)\n            if (range.to > pos)\n                return Math.max(pos, range.from);\n        return this.end;\n    }\n    /// Look at a code unit near the stream position. `.peek(0)` equals\n    /// `.next`, `.peek(-1)` gives you the previous character, and so\n    /// on.\n    ///\n    /// Note that looking around during tokenizing creates dependencies\n    /// on potentially far-away content, which may reduce the\n    /// effectiveness incremental parsing\u2014when looking forward\u2014or even\n    /// cause invalid reparses when looking backward more than 25 code\n    /// units, since the library does not track lookbehind.\n    peek(offset) {\n        let idx = this.chunkOff + offset, pos, result;\n        if (idx >= 0 && idx < this.chunk.length) {\n            pos = this.pos + offset;\n            result = this.chunk.charCodeAt(idx);\n        }\n        else {\n            let resolved = this.resolveOffset(offset, 1);\n            if (resolved == null)\n                return -1;\n            pos = resolved;\n            if (pos >= this.chunk2Pos && pos < this.chunk2Pos + this.chunk2.length) {\n                result = this.chunk2.charCodeAt(pos - this.chunk2Pos);\n            }\n            else {\n                let i = this.rangeIndex, range = this.range;\n                while (range.to <= pos)\n                    range = this.ranges[++i];\n                this.chunk2 = this.input.chunk(this.chunk2Pos = pos);\n                if (pos + this.chunk2.length > range.to)\n                    this.chunk2 = this.chunk2.slice(0, range.to - pos);\n                result = this.chunk2.charCodeAt(0);\n            }\n        }\n        if (pos >= this.token.lookAhead)\n            this.token.lookAhead = pos + 1;\n        return result;\n    }\n    /// Accept a token. By default, the end of the token is set to the\n    /// current stream position, but you can pass an offset (relative to\n    /// the stream position) to change that.\n    acceptToken(token, endOffset = 0) {\n        let end = endOffset ? this.resolveOffset(endOffset, -1) : this.pos;\n        if (end == null || end < this.token.start)\n            throw new RangeError(\"Token end out of bounds\");\n        this.token.value = token;\n        this.token.end = end;\n    }\n    getChunk() {\n        if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {\n            let { chunk, chunkPos } = this;\n            this.chunk = this.chunk2;\n            this.chunkPos = this.chunk2Pos;\n            this.chunk2 = chunk;\n            this.chunk2Pos = chunkPos;\n            this.chunkOff = this.pos - this.chunkPos;\n        }\n        else {\n            this.chunk2 = this.chunk;\n            this.chunk2Pos = this.chunkPos;\n            let nextChunk = this.input.chunk(this.pos);\n            let end = this.pos + nextChunk.length;\n            this.chunk = end > this.range.to ? nextChunk.slice(0, this.range.to - this.pos) : nextChunk;\n            this.chunkPos = this.pos;\n            this.chunkOff = 0;\n        }\n    }\n    readNext() {\n        if (this.chunkOff >= this.chunk.length) {\n            this.getChunk();\n            if (this.chunkOff == this.chunk.length)\n                return this.next = -1;\n        }\n        return this.next = this.chunk.charCodeAt(this.chunkOff);\n    }\n    /// Move the stream forward N (defaults to 1) code units. Returns\n    /// the new value of [`next`](#lr.InputStream.next).\n    advance(n = 1) {\n        this.chunkOff += n;\n        while (this.pos + n >= this.range.to) {\n            if (this.rangeIndex == this.ranges.length - 1)\n                return this.setDone();\n            n -= this.range.to - this.pos;\n            this.range = this.ranges[++this.rangeIndex];\n            this.pos = this.range.from;\n        }\n        this.pos += n;\n        if (this.pos >= this.token.lookAhead)\n            this.token.lookAhead = this.pos + 1;\n        return this.readNext();\n    }\n    setDone() {\n        this.pos = this.chunkPos = this.end;\n        this.range = this.ranges[this.rangeIndex = this.ranges.length - 1];\n        this.chunk = \"\";\n        return this.next = -1;\n    }\n    /// @internal\n    reset(pos, token) {\n        if (token) {\n            this.token = token;\n            token.start = pos;\n            token.lookAhead = pos + 1;\n            token.value = token.extended = -1;\n        }\n        else {\n            this.token = nullToken;\n        }\n        if (this.pos != pos) {\n            this.pos = pos;\n            if (pos == this.end) {\n                this.setDone();\n                return this;\n            }\n            while (pos < this.range.from)\n                this.range = this.ranges[--this.rangeIndex];\n            while (pos >= this.range.to)\n                this.range = this.ranges[++this.rangeIndex];\n            if (pos >= this.chunkPos && pos < this.chunkPos + this.chunk.length) {\n                this.chunkOff = pos - this.chunkPos;\n            }\n            else {\n                this.chunk = \"\";\n                this.chunkOff = 0;\n            }\n            this.readNext();\n        }\n        return this;\n    }\n    /// @internal\n    read(from, to) {\n        if (from >= this.chunkPos && to <= this.chunkPos + this.chunk.length)\n            return this.chunk.slice(from - this.chunkPos, to - this.chunkPos);\n        if (from >= this.chunk2Pos && to <= this.chunk2Pos + this.chunk2.length)\n            return this.chunk2.slice(from - this.chunk2Pos, to - this.chunk2Pos);\n        if (from >= this.range.from && to <= this.range.to)\n            return this.input.read(from, to);\n        let result = \"\";\n        for (let r of this.ranges) {\n            if (r.from >= to)\n                break;\n            if (r.to > from)\n                result += this.input.read(Math.max(r.from, from), Math.min(r.to, to));\n        }\n        return result;\n    }\n}\n/// @internal\nclass TokenGroup {\n    constructor(data, id) {\n        this.data = data;\n        this.id = id;\n    }\n    token(input, stack) { readToken(this.data, input, stack, this.id); }\n}\nTokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;\n/// `@external tokens` declarations in the grammar should resolve to\n/// an instance of this class.\nclass ExternalTokenizer {\n    /// Create a tokenizer. The first argument is the function that,\n    /// given an input stream, scans for the types of tokens it\n    /// recognizes at the stream's position, and calls\n    /// [`acceptToken`](#lr.InputStream.acceptToken) when it finds\n    /// one.\n    constructor(\n    /// @internal\n    token, options = {}) {\n        this.token = token;\n        this.contextual = !!options.contextual;\n        this.fallback = !!options.fallback;\n        this.extend = !!options.extend;\n    }\n}\n// Tokenizer data is stored a big uint16 array containing, for each\n// state:\n//\n//  - A group bitmask, indicating what token groups are reachable from\n//    this state, so that paths that can only lead to tokens not in\n//    any of the current groups can be cut off early.\n//\n//  - The position of the end of the state's sequence of accepting\n//    tokens\n//\n//  - The number of outgoing edges for the state\n//\n//  - The accepting tokens, as (token id, group mask) pairs\n//\n//  - The outgoing edges, as (start character, end character, state\n//    index) triples, with end character being exclusive\n//\n// This function interprets that data, running through a stream as\n// long as new states with the a matching group mask can be reached,\n// and updating `input.token` when it matches a token.\nfunction readToken(data, input, stack, group) {\n    let state = 0, groupMask = 1 << group, { parser } = stack.p, { dialect } = parser;\n    scan: for (;;) {\n        if ((groupMask & data[state]) == 0)\n            break;\n        let accEnd = data[state + 1];\n        // Check whether this state can lead to a token in the current group\n        // Accept tokens in this state, possibly overwriting\n        // lower-precedence / shorter tokens\n        for (let i = state + 3; i < accEnd; i += 2)\n            if ((data[i + 1] & groupMask) > 0) {\n                let term = data[i];\n                if (dialect.allows(term) &&\n                    (input.token.value == -1 || input.token.value == term || parser.overrides(term, input.token.value))) {\n                    input.acceptToken(term);\n                    break;\n                }\n            }\n        let next = input.next, low = 0, high = data[state + 2];\n        // Special case for EOF\n        if (input.next < 0 && high > low && data[accEnd + high * 3 - 3] == 65535 /* End */) {\n            state = data[accEnd + high * 3 - 1];\n            continue scan;\n        }\n        // Do a binary search on the state's edges\n        for (; low < high;) {\n            let mid = (low + high) >> 1;\n            let index = accEnd + mid + (mid << 1);\n            let from = data[index], to = data[index + 1];\n            if (next < from)\n                high = mid;\n            else if (next >= to)\n                low = mid + 1;\n            else {\n                state = data[index + 2];\n                input.advance();\n                continue scan;\n            }\n        }\n        break;\n    }\n}\n\n// See lezer-generator/src/encode.ts for comments about the encoding\n// used here\nfunction decodeArray(input, Type = Uint16Array) {\n    if (typeof input != \"string\")\n        return input;\n    let array = null;\n    for (let pos = 0, out = 0; pos < input.length;) {\n        let value = 0;\n        for (;;) {\n            let next = input.charCodeAt(pos++), stop = false;\n            if (next == 126 /* BigValCode */) {\n                value = 65535 /* BigVal */;\n                break;\n            }\n            if (next >= 92 /* Gap2 */)\n                next--;\n            if (next >= 34 /* Gap1 */)\n                next--;\n            let digit = next - 32 /* Start */;\n            if (digit >= 46 /* Base */) {\n                digit -= 46 /* Base */;\n                stop = true;\n            }\n            value += digit;\n            if (stop)\n                break;\n            value *= 46 /* Base */;\n        }\n        if (array)\n            array[out++] = value;\n        else\n            array = new Type(value);\n    }\n    return array;\n}\n\n// Environment variable used to control console output\nconst verbose = typeof process != \"undefined\" && process.env && /\\bparse\\b/.test(process.env.LOG);\nlet stackIDs = null;\nvar Safety;\n(function (Safety) {\n    Safety[Safety[\"Margin\"] = 25] = \"Margin\";\n})(Safety || (Safety = {}));\nfunction cutAt(tree, pos, side) {\n    let cursor = tree.cursor(IterMode.IncludeAnonymous);\n    cursor.moveTo(pos);\n    for (;;) {\n        if (!(side < 0 ? cursor.childBefore(pos) : cursor.childAfter(pos)))\n            for (;;) {\n                if ((side < 0 ? cursor.to < pos : cursor.from > pos) && !cursor.type.isError)\n                    return side < 0 ? Math.max(0, Math.min(cursor.to - 1, pos - 25 /* Margin */))\n                        : Math.min(tree.length, Math.max(cursor.from + 1, pos + 25 /* Margin */));\n                if (side < 0 ? cursor.prevSibling() : cursor.nextSibling())\n                    break;\n                if (!cursor.parent())\n                    return side < 0 ? 0 : tree.length;\n            }\n    }\n}\nclass FragmentCursor {\n    constructor(fragments, nodeSet) {\n        this.fragments = fragments;\n        this.nodeSet = nodeSet;\n        this.i = 0;\n        this.fragment = null;\n        this.safeFrom = -1;\n        this.safeTo = -1;\n        this.trees = [];\n        this.start = [];\n        this.index = [];\n        this.nextFragment();\n    }\n    nextFragment() {\n        let fr = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];\n        if (fr) {\n            this.safeFrom = fr.openStart ? cutAt(fr.tree, fr.from + fr.offset, 1) - fr.offset : fr.from;\n            this.safeTo = fr.openEnd ? cutAt(fr.tree, fr.to + fr.offset, -1) - fr.offset : fr.to;\n            while (this.trees.length) {\n                this.trees.pop();\n                this.start.pop();\n                this.index.pop();\n            }\n            this.trees.push(fr.tree);\n            this.start.push(-fr.offset);\n            this.index.push(0);\n            this.nextStart = this.safeFrom;\n        }\n        else {\n            this.nextStart = 1e9;\n        }\n    }\n    // `pos` must be >= any previously given `pos` for this cursor\n    nodeAt(pos) {\n        if (pos < this.nextStart)\n            return null;\n        while (this.fragment && this.safeTo <= pos)\n            this.nextFragment();\n        if (!this.fragment)\n            return null;\n        for (;;) {\n            let last = this.trees.length - 1;\n            if (last < 0) { // End of tree\n                this.nextFragment();\n                return null;\n            }\n            let top = this.trees[last], index = this.index[last];\n            if (index == top.children.length) {\n                this.trees.pop();\n                this.start.pop();\n                this.index.pop();\n                continue;\n            }\n            let next = top.children[index];\n            let start = this.start[last] + top.positions[index];\n            if (start > pos) {\n                this.nextStart = start;\n                return null;\n            }\n            if (next instanceof Tree) {\n                if (start == pos) {\n                    if (start < this.safeFrom)\n                        return null;\n                    let end = start + next.length;\n                    if (end <= this.safeTo) {\n                        let lookAhead = next.prop(NodeProp.lookAhead);\n                        if (!lookAhead || end + lookAhead < this.fragment.to)\n                            return next;\n                    }\n                }\n                this.index[last]++;\n                if (start + next.length >= Math.max(this.safeFrom, pos)) { // Enter this node\n                    this.trees.push(next);\n                    this.start.push(start);\n                    this.index.push(0);\n                }\n            }\n            else {\n                this.index[last]++;\n                this.nextStart = start + next.length;\n            }\n        }\n    }\n}\nclass TokenCache {\n    constructor(parser, stream) {\n        this.stream = stream;\n        this.tokens = [];\n        this.mainToken = null;\n        this.actions = [];\n        this.tokens = parser.tokenizers.map(_ => new CachedToken);\n    }\n    getActions(stack) {\n        let actionIndex = 0;\n        let main = null;\n        let { parser } = stack.p, { tokenizers } = parser;\n        let mask = parser.stateSlot(stack.state, 3 /* TokenizerMask */);\n        let context = stack.curContext ? stack.curContext.hash : 0;\n        let lookAhead = 0;\n        for (let i = 0; i < tokenizers.length; i++) {\n            if (((1 << i) & mask) == 0)\n                continue;\n            let tokenizer = tokenizers[i], token = this.tokens[i];\n            if (main && !tokenizer.fallback)\n                continue;\n            if (tokenizer.contextual || token.start != stack.pos || token.mask != mask || token.context != context) {\n                this.updateCachedToken(token, tokenizer, stack);\n                token.mask = mask;\n                token.context = context;\n            }\n            if (token.lookAhead > token.end + 25 /* Margin */)\n                lookAhead = Math.max(token.lookAhead, lookAhead);\n            if (token.value != 0 /* Err */) {\n                let startIndex = actionIndex;\n                if (token.extended > -1)\n                    actionIndex = this.addActions(stack, token.extended, token.end, actionIndex);\n                actionIndex = this.addActions(stack, token.value, token.end, actionIndex);\n                if (!tokenizer.extend) {\n                    main = token;\n                    if (actionIndex > startIndex)\n                        break;\n                }\n            }\n        }\n        while (this.actions.length > actionIndex)\n            this.actions.pop();\n        if (lookAhead)\n            stack.setLookAhead(lookAhead);\n        if (!main && stack.pos == this.stream.end) {\n            main = new CachedToken;\n            main.value = stack.p.parser.eofTerm;\n            main.start = main.end = stack.pos;\n            actionIndex = this.addActions(stack, main.value, main.end, actionIndex);\n        }\n        this.mainToken = main;\n        return this.actions;\n    }\n    getMainToken(stack) {\n        if (this.mainToken)\n            return this.mainToken;\n        let main = new CachedToken, { pos, p } = stack;\n        main.start = pos;\n        main.end = Math.min(pos + 1, p.stream.end);\n        main.value = pos == p.stream.end ? p.parser.eofTerm : 0 /* Err */;\n        return main;\n    }\n    updateCachedToken(token, tokenizer, stack) {\n        let start = this.stream.clipPos(stack.pos);\n        tokenizer.token(this.stream.reset(start, token), stack);\n        if (token.value > -1) {\n            let { parser } = stack.p;\n            for (let i = 0; i < parser.specialized.length; i++)\n                if (parser.specialized[i] == token.value) {\n                    let result = parser.specializers[i](this.stream.read(token.start, token.end), stack);\n                    if (result >= 0 && stack.p.parser.dialect.allows(result >> 1)) {\n                        if ((result & 1) == 0 /* Specialize */)\n                            token.value = result >> 1;\n                        else\n                            token.extended = result >> 1;\n                        break;\n                    }\n                }\n        }\n        else {\n            token.value = 0 /* Err */;\n            token.end = this.stream.clipPos(start + 1);\n        }\n    }\n    putAction(action, token, end, index) {\n        // Don't add duplicate actions\n        for (let i = 0; i < index; i += 3)\n            if (this.actions[i] == action)\n                return index;\n        this.actions[index++] = action;\n        this.actions[index++] = token;\n        this.actions[index++] = end;\n        return index;\n    }\n    addActions(stack, token, end, index) {\n        let { state } = stack, { parser } = stack.p, { data } = parser;\n        for (let set = 0; set < 2; set++) {\n            for (let i = parser.stateSlot(state, set ? 2 /* Skip */ : 1 /* Actions */);; i += 3) {\n                if (data[i] == 65535 /* End */) {\n                    if (data[i + 1] == 1 /* Next */) {\n                        i = pair(data, i + 2);\n                    }\n                    else {\n                        if (index == 0 && data[i + 1] == 2 /* Other */)\n                            index = this.putAction(pair(data, i + 2), token, end, index);\n                        break;\n                    }\n                }\n                if (data[i] == token)\n                    index = this.putAction(pair(data, i + 1), token, end, index);\n            }\n        }\n        return index;\n    }\n}\nvar Rec;\n(function (Rec) {\n    Rec[Rec[\"Distance\"] = 5] = \"Distance\";\n    Rec[Rec[\"MaxRemainingPerStep\"] = 3] = \"MaxRemainingPerStep\";\n    // When two stacks have been running independently long enough to\n    // add this many elements to their buffers, prune one.\n    Rec[Rec[\"MinBufferLengthPrune\"] = 500] = \"MinBufferLengthPrune\";\n    Rec[Rec[\"ForceReduceLimit\"] = 10] = \"ForceReduceLimit\";\n    // Once a stack reaches this depth (in .stack.length) force-reduce\n    // it back to CutTo to avoid creating trees that overflow the stack\n    // on recursive traversal.\n    Rec[Rec[\"CutDepth\"] = 15000] = \"CutDepth\";\n    Rec[Rec[\"CutTo\"] = 9000] = \"CutTo\";\n})(Rec || (Rec = {}));\nclass Parse {\n    constructor(parser, input, fragments, ranges) {\n        this.parser = parser;\n        this.input = input;\n        this.ranges = ranges;\n        this.recovering = 0;\n        this.nextStackID = 0x2654; // \u2654, \u2655, \u2656, \u2657, \u2658, \u2659, \u2660, \u2661, \u2662, \u2663, \u2664, \u2665, \u2666, \u2667\n        this.minStackPos = 0;\n        this.reused = [];\n        this.stoppedAt = null;\n        this.stream = new InputStream(input, ranges);\n        this.tokens = new TokenCache(parser, this.stream);\n        this.topTerm = parser.top[1];\n        let { from } = ranges[0];\n        this.stacks = [Stack.start(this, parser.top[0], from)];\n        this.fragments = fragments.length && this.stream.end - from > parser.bufferLength * 4\n            ? new FragmentCursor(fragments, parser.nodeSet) : null;\n    }\n    get parsedPos() {\n        return this.minStackPos;\n    }\n    // Move the parser forward. This will process all parse stacks at\n    // `this.pos` and try to advance them to a further position. If no\n    // stack for such a position is found, it'll start error-recovery.\n    //\n    // When the parse is finished, this will return a syntax tree. When\n    // not, it returns `null`.\n    advance() {\n        let stacks = this.stacks, pos = this.minStackPos;\n        // This will hold stacks beyond `pos`.\n        let newStacks = this.stacks = [];\n        let stopped, stoppedTokens;\n        // Keep advancing any stacks at `pos` until they either move\n        // forward or can't be advanced. Gather stacks that can't be\n        // advanced further in `stopped`.\n        for (let i = 0; i < stacks.length; i++) {\n            let stack = stacks[i];\n            for (;;) {\n                this.tokens.mainToken = null;\n                if (stack.pos > pos) {\n                    newStacks.push(stack);\n                }\n                else if (this.advanceStack(stack, newStacks, stacks)) {\n                    continue;\n                }\n                else {\n                    if (!stopped) {\n                        stopped = [];\n                        stoppedTokens = [];\n                    }\n                    stopped.push(stack);\n                    let tok = this.tokens.getMainToken(stack);\n                    stoppedTokens.push(tok.value, tok.end);\n                }\n                break;\n            }\n        }\n        if (!newStacks.length) {\n            let finished = stopped && findFinished(stopped);\n            if (finished)\n                return this.stackToTree(finished);\n            if (this.parser.strict) {\n                if (verbose && stopped)\n                    console.log(\"Stuck with token \" + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : \"none\"));\n                throw new SyntaxError(\"No parse at \" + pos);\n            }\n            if (!this.recovering)\n                this.recovering = 5 /* Distance */;\n        }\n        if (this.recovering && stopped) {\n            let finished = this.stoppedAt != null && stopped[0].pos > this.stoppedAt ? stopped[0]\n                : this.runRecovery(stopped, stoppedTokens, newStacks);\n            if (finished)\n                return this.stackToTree(finished.forceAll());\n        }\n        if (this.recovering) {\n            let maxRemaining = this.recovering == 1 ? 1 : this.recovering * 3 /* MaxRemainingPerStep */;\n            if (newStacks.length > maxRemaining) {\n                newStacks.sort((a, b) => b.score - a.score);\n                while (newStacks.length > maxRemaining)\n                    newStacks.pop();\n            }\n            if (newStacks.some(s => s.reducePos > pos))\n                this.recovering--;\n        }\n        else if (newStacks.length > 1) {\n            // Prune stacks that are in the same state, or that have been\n            // running without splitting for a while, to avoid getting stuck\n            // with multiple successful stacks running endlessly on.\n            outer: for (let i = 0; i < newStacks.length - 1; i++) {\n                let stack = newStacks[i];\n                for (let j = i + 1; j < newStacks.length; j++) {\n                    let other = newStacks[j];\n                    if (stack.sameState(other) ||\n                        stack.buffer.length > 500 /* MinBufferLengthPrune */ && other.buffer.length > 500 /* MinBufferLengthPrune */) {\n                        if (((stack.score - other.score) || (stack.buffer.length - other.buffer.length)) > 0) {\n                            newStacks.splice(j--, 1);\n                        }\n                        else {\n                            newStacks.splice(i--, 1);\n                            continue outer;\n                        }\n                    }\n                }\n            }\n        }\n        this.minStackPos = newStacks[0].pos;\n        for (let i = 1; i < newStacks.length; i++)\n            if (newStacks[i].pos < this.minStackPos)\n                this.minStackPos = newStacks[i].pos;\n        return null;\n    }\n    stopAt(pos) {\n        if (this.stoppedAt != null && this.stoppedAt < pos)\n            throw new RangeError(\"Can't move stoppedAt forward\");\n        this.stoppedAt = pos;\n    }\n    // Returns an updated version of the given stack, or null if the\n    // stack can't advance normally. When `split` and `stacks` are\n    // given, stacks split off by ambiguous operations will be pushed to\n    // `split`, or added to `stacks` if they move `pos` forward.\n    advanceStack(stack, stacks, split) {\n        let start = stack.pos, { parser } = this;\n        let base = verbose ? this.stackID(stack) + \" -> \" : \"\";\n        if (this.stoppedAt != null && start > this.stoppedAt)\n            return stack.forceReduce() ? stack : null;\n        if (this.fragments) {\n            let strictCx = stack.curContext && stack.curContext.tracker.strict, cxHash = strictCx ? stack.curContext.hash : 0;\n            for (let cached = this.fragments.nodeAt(start); cached;) {\n                let match = this.parser.nodeSet.types[cached.type.id] == cached.type ? parser.getGoto(stack.state, cached.type.id) : -1;\n                if (match > -1 && cached.length && (!strictCx || (cached.prop(NodeProp.contextHash) || 0) == cxHash)) {\n                    stack.useNode(cached, match);\n                    if (verbose)\n                        console.log(base + this.stackID(stack) + ` (via reuse of ${parser.getName(cached.type.id)})`);\n                    return true;\n                }\n                if (!(cached instanceof Tree) || cached.children.length == 0 || cached.positions[0] > 0)\n                    break;\n                let inner = cached.children[0];\n                if (inner instanceof Tree && cached.positions[0] == 0)\n                    cached = inner;\n                else\n                    break;\n            }\n        }\n        let defaultReduce = parser.stateSlot(stack.state, 4 /* DefaultReduce */);\n        if (defaultReduce > 0) {\n            stack.reduce(defaultReduce);\n            if (verbose)\n                console.log(base + this.stackID(stack) + ` (via always-reduce ${parser.getName(defaultReduce & 65535 /* ValueMask */)})`);\n            return true;\n        }\n        if (stack.stack.length >= 15000 /* CutDepth */) {\n            while (stack.stack.length > 9000 /* CutTo */ && stack.forceReduce()) { }\n        }\n        let actions = this.tokens.getActions(stack);\n        for (let i = 0; i < actions.length;) {\n            let action = actions[i++], term = actions[i++], end = actions[i++];\n            let last = i == actions.length || !split;\n            let localStack = last ? stack : stack.split();\n            localStack.apply(action, term, end);\n            if (verbose)\n                console.log(base + this.stackID(localStack) + ` (via ${(action & 65536 /* ReduceFlag */) == 0 ? \"shift\"\n                    : `reduce of ${parser.getName(action & 65535 /* ValueMask */)}`} for ${parser.getName(term)} @ ${start}${localStack == stack ? \"\" : \", split\"})`);\n            if (last)\n                return true;\n            else if (localStack.pos > start)\n                stacks.push(localStack);\n            else\n                split.push(localStack);\n        }\n        return false;\n    }\n    // Advance a given stack forward as far as it will go. Returns the\n    // (possibly updated) stack if it got stuck, or null if it moved\n    // forward and was given to `pushStackDedup`.\n    advanceFully(stack, newStacks) {\n        let pos = stack.pos;\n        for (;;) {\n            if (!this.advanceStack(stack, null, null))\n                return false;\n            if (stack.pos > pos) {\n                pushStackDedup(stack, newStacks);\n                return true;\n            }\n        }\n    }\n    runRecovery(stacks, tokens, newStacks) {\n        let finished = null, restarted = false;\n        for (let i = 0; i < stacks.length; i++) {\n            let stack = stacks[i], token = tokens[i << 1], tokenEnd = tokens[(i << 1) + 1];\n            let base = verbose ? this.stackID(stack) + \" -> \" : \"\";\n            if (stack.deadEnd) {\n                if (restarted)\n                    continue;\n                restarted = true;\n                stack.restart();\n                if (verbose)\n                    console.log(base + this.stackID(stack) + \" (restarted)\");\n                let done = this.advanceFully(stack, newStacks);\n                if (done)\n                    continue;\n            }\n            let force = stack.split(), forceBase = base;\n            for (let j = 0; force.forceReduce() && j < 10 /* ForceReduceLimit */; j++) {\n                if (verbose)\n                    console.log(forceBase + this.stackID(force) + \" (via force-reduce)\");\n                let done = this.advanceFully(force, newStacks);\n                if (done)\n                    break;\n                if (verbose)\n                    forceBase = this.stackID(force) + \" -> \";\n            }\n            for (let insert of stack.recoverByInsert(token)) {\n                if (verbose)\n                    console.log(base + this.stackID(insert) + \" (via recover-insert)\");\n                this.advanceFully(insert, newStacks);\n            }\n            if (this.stream.end > stack.pos) {\n                if (tokenEnd == stack.pos) {\n                    tokenEnd++;\n                    token = 0 /* Err */;\n                }\n                stack.recoverByDelete(token, tokenEnd);\n                if (verbose)\n                    console.log(base + this.stackID(stack) + ` (via recover-delete ${this.parser.getName(token)})`);\n                pushStackDedup(stack, newStacks);\n            }\n            else if (!finished || finished.score < stack.score) {\n                finished = stack;\n            }\n        }\n        return finished;\n    }\n    // Convert the stack's buffer to a syntax tree.\n    stackToTree(stack) {\n        stack.close();\n        return Tree.build({ buffer: StackBufferCursor.create(stack),\n            nodeSet: this.parser.nodeSet,\n            topID: this.topTerm,\n            maxBufferLength: this.parser.bufferLength,\n            reused: this.reused,\n            start: this.ranges[0].from,\n            length: stack.pos - this.ranges[0].from,\n            minRepeatType: this.parser.minRepeatTerm });\n    }\n    stackID(stack) {\n        let id = (stackIDs || (stackIDs = new WeakMap)).get(stack);\n        if (!id)\n            stackIDs.set(stack, id = String.fromCodePoint(this.nextStackID++));\n        return id + stack;\n    }\n}\nfunction pushStackDedup(stack, newStacks) {\n    for (let i = 0; i < newStacks.length; i++) {\n        let other = newStacks[i];\n        if (other.pos == stack.pos && other.sameState(stack)) {\n            if (newStacks[i].score < stack.score)\n                newStacks[i] = stack;\n            return;\n        }\n    }\n    newStacks.push(stack);\n}\nclass Dialect {\n    constructor(source, flags, disabled) {\n        this.source = source;\n        this.flags = flags;\n        this.disabled = disabled;\n    }\n    allows(term) { return !this.disabled || this.disabled[term] == 0; }\n}\nconst id = x => x;\n/// Context trackers are used to track stateful context (such as\n/// indentation in the Python grammar, or parent elements in the XML\n/// grammar) needed by external tokenizers. You declare them in a\n/// grammar file as `@context exportName from \"module\"`.\n///\n/// Context values should be immutable, and can be updated (replaced)\n/// on shift or reduce actions.\n///\n/// The export used in a `@context` declaration should be of this\n/// type.\nclass ContextTracker {\n    /// Define a context tracker.\n    constructor(spec) {\n        this.start = spec.start;\n        this.shift = spec.shift || id;\n        this.reduce = spec.reduce || id;\n        this.reuse = spec.reuse || id;\n        this.hash = spec.hash || (() => 0);\n        this.strict = spec.strict !== false;\n    }\n}\n/// Holds the parse tables for a given grammar, as generated by\n/// `lezer-generator`, and provides [methods](#common.Parser) to parse\n/// content with.\nclass LRParser extends Parser {\n    /// @internal\n    constructor(spec) {\n        super();\n        /// @internal\n        this.wrappers = [];\n        if (spec.version != 14 /* Version */)\n            throw new RangeError(`Parser version (${spec.version}) doesn't match runtime version (${14 /* Version */})`);\n        let nodeNames = spec.nodeNames.split(\" \");\n        this.minRepeatTerm = nodeNames.length;\n        for (let i = 0; i < spec.repeatNodeCount; i++)\n            nodeNames.push(\"\");\n        let topTerms = Object.keys(spec.topRules).map(r => spec.topRules[r][1]);\n        let nodeProps = [];\n        for (let i = 0; i < nodeNames.length; i++)\n            nodeProps.push([]);\n        function setProp(nodeID, prop, value) {\n            nodeProps[nodeID].push([prop, prop.deserialize(String(value))]);\n        }\n        if (spec.nodeProps)\n            for (let propSpec of spec.nodeProps) {\n                let prop = propSpec[0];\n                if (typeof prop == \"string\")\n                    prop = NodeProp[prop];\n                for (let i = 1; i < propSpec.length;) {\n                    let next = propSpec[i++];\n                    if (next >= 0) {\n                        setProp(next, prop, propSpec[i++]);\n                    }\n                    else {\n                        let value = propSpec[i + -next];\n                        for (let j = -next; j > 0; j--)\n                            setProp(propSpec[i++], prop, value);\n                        i++;\n                    }\n                }\n            }\n        this.nodeSet = new NodeSet(nodeNames.map((name, i) => NodeType.define({\n            name: i >= this.minRepeatTerm ? undefined : name,\n            id: i,\n            props: nodeProps[i],\n            top: topTerms.indexOf(i) > -1,\n            error: i == 0,\n            skipped: spec.skippedNodes && spec.skippedNodes.indexOf(i) > -1\n        })));\n        if (spec.propSources)\n            this.nodeSet = this.nodeSet.extend(...spec.propSources);\n        this.strict = false;\n        this.bufferLength = DefaultBufferLength;\n        let tokenArray = decodeArray(spec.tokenData);\n        this.context = spec.context;\n        this.specializerSpecs = spec.specialized || [];\n        this.specialized = new Uint16Array(this.specializerSpecs.length);\n        for (let i = 0; i < this.specializerSpecs.length; i++)\n            this.specialized[i] = this.specializerSpecs[i].term;\n        this.specializers = this.specializerSpecs.map(getSpecializer);\n        this.states = decodeArray(spec.states, Uint32Array);\n        this.data = decodeArray(spec.stateData);\n        this.goto = decodeArray(spec.goto);\n        this.maxTerm = spec.maxTerm;\n        this.tokenizers = spec.tokenizers.map(value => typeof value == \"number\" ? new TokenGroup(tokenArray, value) : value);\n        this.topRules = spec.topRules;\n        this.dialects = spec.dialects || {};\n        this.dynamicPrecedences = spec.dynamicPrecedences || null;\n        this.tokenPrecTable = spec.tokenPrec;\n        this.termNames = spec.termNames || null;\n        this.maxNode = this.nodeSet.types.length - 1;\n        this.dialect = this.parseDialect();\n        this.top = this.topRules[Object.keys(this.topRules)[0]];\n    }\n    createParse(input, fragments, ranges) {\n        let parse = new Parse(this, input, fragments, ranges);\n        for (let w of this.wrappers)\n            parse = w(parse, input, fragments, ranges);\n        return parse;\n    }\n    /// Get a goto table entry @internal\n    getGoto(state, term, loose = false) {\n        let table = this.goto;\n        if (term >= table[0])\n            return -1;\n        for (let pos = table[term + 1];;) {\n            let groupTag = table[pos++], last = groupTag & 1;\n            let target = table[pos++];\n            if (last && loose)\n                return target;\n            for (let end = pos + (groupTag >> 1); pos < end; pos++)\n                if (table[pos] == state)\n                    return target;\n            if (last)\n                return -1;\n        }\n    }\n    /// Check if this state has an action for a given terminal @internal\n    hasAction(state, terminal) {\n        let data = this.data;\n        for (let set = 0; set < 2; set++) {\n            for (let i = this.stateSlot(state, set ? 2 /* Skip */ : 1 /* Actions */), next;; i += 3) {\n                if ((next = data[i]) == 65535 /* End */) {\n                    if (data[i + 1] == 1 /* Next */)\n                        next = data[i = pair(data, i + 2)];\n                    else if (data[i + 1] == 2 /* Other */)\n                        return pair(data, i + 2);\n                    else\n                        break;\n                }\n                if (next == terminal || next == 0 /* Err */)\n                    return pair(data, i + 1);\n            }\n        }\n        return 0;\n    }\n    /// @internal\n    stateSlot(state, slot) {\n        return this.states[(state * 6 /* Size */) + slot];\n    }\n    /// @internal\n    stateFlag(state, flag) {\n        return (this.stateSlot(state, 0 /* Flags */) & flag) > 0;\n    }\n    /// @internal\n    validAction(state, action) {\n        if (action == this.stateSlot(state, 4 /* DefaultReduce */))\n            return true;\n        for (let i = this.stateSlot(state, 1 /* Actions */);; i += 3) {\n            if (this.data[i] == 65535 /* End */) {\n                if (this.data[i + 1] == 1 /* Next */)\n                    i = pair(this.data, i + 2);\n                else\n                    return false;\n            }\n            if (action == pair(this.data, i + 1))\n                return true;\n        }\n    }\n    /// Get the states that can follow this one through shift actions or\n    /// goto jumps. @internal\n    nextStates(state) {\n        let result = [];\n        for (let i = this.stateSlot(state, 1 /* Actions */);; i += 3) {\n            if (this.data[i] == 65535 /* End */) {\n                if (this.data[i + 1] == 1 /* Next */)\n                    i = pair(this.data, i + 2);\n                else\n                    break;\n            }\n            if ((this.data[i + 2] & (65536 /* ReduceFlag */ >> 16)) == 0) {\n                let value = this.data[i + 1];\n                if (!result.some((v, i) => (i & 1) && v == value))\n                    result.push(this.data[i], value);\n            }\n        }\n        return result;\n    }\n    /// @internal\n    overrides(token, prev) {\n        let iPrev = findOffset(this.data, this.tokenPrecTable, prev);\n        return iPrev < 0 || findOffset(this.data, this.tokenPrecTable, token) < iPrev;\n    }\n    /// Configure the parser. Returns a new parser instance that has the\n    /// given settings modified. Settings not provided in `config` are\n    /// kept from the original parser.\n    configure(config) {\n        // Hideous reflection-based kludge to make it easy to create a\n        // slightly modified copy of a parser.\n        let copy = Object.assign(Object.create(LRParser.prototype), this);\n        if (config.props)\n            copy.nodeSet = this.nodeSet.extend(...config.props);\n        if (config.top) {\n            let info = this.topRules[config.top];\n            if (!info)\n                throw new RangeError(`Invalid top rule name ${config.top}`);\n            copy.top = info;\n        }\n        if (config.tokenizers)\n            copy.tokenizers = this.tokenizers.map(t => {\n                let found = config.tokenizers.find(r => r.from == t);\n                return found ? found.to : t;\n            });\n        if (config.specializers) {\n            copy.specializers = this.specializers.slice();\n            copy.specializerSpecs = this.specializerSpecs.map((s, i) => {\n                let found = config.specializers.find(r => r.from == s.external);\n                if (!found)\n                    return s;\n                let spec = Object.assign(Object.assign({}, s), { external: found.to });\n                copy.specializers[i] = getSpecializer(spec);\n                return spec;\n            });\n        }\n        if (config.contextTracker)\n            copy.context = config.contextTracker;\n        if (config.dialect)\n            copy.dialect = this.parseDialect(config.dialect);\n        if (config.strict != null)\n            copy.strict = config.strict;\n        if (config.wrap)\n            copy.wrappers = copy.wrappers.concat(config.wrap);\n        if (config.bufferLength != null)\n            copy.bufferLength = config.bufferLength;\n        return copy;\n    }\n    /// Tells you whether any [parse wrappers](#lr.ParserConfig.wrap)\n    /// are registered for this parser.\n    hasWrappers() {\n        return this.wrappers.length > 0;\n    }\n    /// Returns the name associated with a given term. This will only\n    /// work for all terms when the parser was generated with the\n    /// `--names` option. By default, only the names of tagged terms are\n    /// stored.\n    getName(term) {\n        return this.termNames ? this.termNames[term] : String(term <= this.maxNode && this.nodeSet.types[term].name || term);\n    }\n    /// The eof term id is always allocated directly after the node\n    /// types. @internal\n    get eofTerm() { return this.maxNode + 1; }\n    /// The type of top node produced by the parser.\n    get topNode() { return this.nodeSet.types[this.top[1]]; }\n    /// @internal\n    dynamicPrecedence(term) {\n        let prec = this.dynamicPrecedences;\n        return prec == null ? 0 : prec[term] || 0;\n    }\n    /// @internal\n    parseDialect(dialect) {\n        let values = Object.keys(this.dialects), flags = values.map(() => false);\n        if (dialect)\n            for (let part of dialect.split(\" \")) {\n                let id = values.indexOf(part);\n                if (id >= 0)\n                    flags[id] = true;\n            }\n        let disabled = null;\n        for (let i = 0; i < values.length; i++)\n            if (!flags[i]) {\n                for (let j = this.dialects[values[i]], id; (id = this.data[j++]) != 65535 /* End */;)\n                    (disabled || (disabled = new Uint8Array(this.maxTerm + 1)))[id] = 1;\n            }\n        return new Dialect(dialect, flags, disabled);\n    }\n    /// Used by the output of the parser generator. Not available to\n    /// user code.\n    static deserialize(spec) {\n        return new LRParser(spec);\n    }\n}\nfunction pair(data, off) { return data[off] | (data[off + 1] << 16); }\nfunction findOffset(data, start, term) {\n    for (let i = start, next; (next = data[i]) != 65535 /* End */; i++)\n        if (next == term)\n            return i - start;\n    return -1;\n}\nfunction findFinished(stacks) {\n    let best = null;\n    for (let stack of stacks) {\n        let stopped = stack.p.stoppedAt;\n        if ((stack.pos == stack.p.stream.end || stopped != null && stack.pos > stopped) &&\n            stack.p.parser.stateFlag(stack.state, 2 /* Accepting */) &&\n            (!best || best.score < stack.score))\n            best = stack;\n    }\n    return best;\n}\nfunction getSpecializer(spec) {\n    if (spec.external) {\n        let mask = spec.extend ? 1 /* Extend */ : 0 /* Specialize */;\n        return (value, stack) => (spec.external(value, stack) << 1) | mask;\n    }\n    return spec.get;\n}\n\nexport { ContextTracker, ExternalTokenizer, InputStream, LRParser, Stack };\n", "// This file was generated by lezer-generator. You probably shouldn't edit it.\nexport const\n  chars = 30,\n  lostLinesStart = 31,\n  Unclear = 1,\n  Document = 2,\n  PartId = 7,\n  FragmentNum = 9,\n  ColumnNum = 11,\n  Inline = 12,\n  LineBreakWrapped = 13,\n  LineBreak = 14,\n  Number = 15,\n  Abbrev = 16,\n  Supplied = 17,\n  CertLow = 18,\n  Text = 22,\n  QuestionMark = 23,\n  LostLines = 24,\n  Illegible = 25,\n  Erasure = 26\n", "import {ExternalTokenizer} from \"@lezer/lr\";\nimport { chars as lp_chars, Unclear, lostLinesStart } from \"./leiden+/parser.terms.js\";\n\n// export const eofToken = new ExternalTokenizer(input => {\n//     if (input.next < 0) input.acceptToken(eof)\n// });\n\n// export const sofToken = new ExternalTokenizer(input => {\n//     if (input.pos === 0) input.acceptToken(sof)\n// });\n\nconst skipped = '() <>?=.0123456789\\[\\]\u301A\u301B';\n\nexport const charsToken = new ExternalTokenizer(input => {\n    let str = '';\n    for(;;) {\n        if (input.next < 0) {\n            break;\n        }\n        if (input.next === 46 && str === 'lost') {\n            input.advance();\n            input.acceptToken(lostLinesStart);\n            return;\n        }\n        const ch = String.fromCharCode(input.next);\n        if (skipped.indexOf(ch) > -1) {\n            break;\n        }\n        const nextChar = input.peek(1);\n        if (nextChar === 0x0323) {\n            break;\n        }\n        str += ch;\n        input.advance();\n    }\n    if (str.length > 0) {\n        input.acceptToken(lp_chars);\n    }\n});\n\nexport const unclearToken = new ExternalTokenizer(input => {\n    let charCount = 0;\n    for(;;) {\n        if (input.next < 0 || skipped.indexOf(String.fromCharCode(input.next)) > -1) {\n            break;\n        }\n        const nextChar = input.peek(1);\n        if (nextChar === 0x0323) {\n            charCount++;\n            input.advance(2);\n        } else {\n            break;\n        }\n    }\n    if (charCount > 0) {\n        input.acceptToken(Unclear);\n    }\n});", "// This file was generated by lezer-generator. You probably shouldn't edit it.\nimport {LRParser} from \"@lezer/lr\"\nimport {charsToken, unclearToken} from \"../tokens\"\nexport const parser = LRParser.deserialize({\n  version: 14,\n  states: \"(QOQOVOOOQOVO'#C_OQOVO'#C`OQOVO'#CaO!eOWO'#CbO!pOVO'#ClO#wOVO'#CmOOOR'#Co'#CoO$ROSO'#CpO!pOVO'#CqOOOR'#DX'#DXOOOR'#Cr'#CrO$WOSO'#CtO!pOVO'#CvOOOR'#Ch'#ChOOOR'#C|'#C|OOOR'#Cw'#CwQQOVOOO$`OVO,58yO$gOVO,58zO$nOVO,58{OQOVO,58|OQOVO,59OOQOVO,59QOOOR'#Cx'#CxO$uOVO,59WO$|OVO,59XOOOR,59X,59XO%WOSO,59XO%]OSO,59[O%bOVO,59]O%lOSO,59`O%qOVO,59bOOOR-E6u-E6uOOOR1G.e1G.eOOOR1G.f1G.fOOOR1G.g1G.gO%xOVO1G.hO&POVO1G.jO&WOVO1G.lOOOR-E6v-E6vOOOR1G.r1G.rOOOR1G.s1G.sO&_OSO1G.sOOOR1G.v1G.vOOOR1G.w1G.wO&dOSO1G.wOOOR1G.z1G.zOOOR1G.|1G.|OOOR7+$S7+$SOOOR7+$U7+$UOOOR7+$W7+$WOOOR7+$_7+$_OOOR7+$c7+$c\",\n  stateData: \"&n~OP^O]^O^^O_^OgZOi^OnZOo[OqPOsQOuROvSOwTOyUO|VO}WO!PXO!QZO!RZO!SZO!U]O~OVeOXfOZgO~OP^O]^O^^O_^OgZOi^OnZOo[OwTOyUO|VO}WO!PXO!QZO!RZO!SZO!U]O~OblOzkO~P!pO_mO~O_oOgoO~OrrO~PQOtsO~PQOttO~PQOxyO~P!pOb{OzzO~P!pOzzO~O!O|O~Ob!OO!O}O~P!pO!T!PO~O!V!QO~P!pOt!RO~PQOt!SO~PQOt!TO~PQOz!UO~O!O!VO~OZ^_Z~\",\n  goto: \"%_|PPP}}}}P}P}P!_PPP!y!yP#c#c#c!yP!yP!y#{$kPPP$}PPPPPPPPPP!ym_OPQRabcdefguvwl_OPQRabcdefguvwahTUX]ijnp}^OPQRTUX]abcdefgijnpuvw}YOPQRTUX]abcdefgijnpuvwQaOQbPQcQQdR^qabcduvwQueQvfRwgQiTQjUQnXQp]Xxijnpm`OPQRabcdefguvw\",\n  nodeNames: \"\u26A0 Unclear Document Div Recto Verso Part PartId Fragment FragmentNum Column ColumnNum Inline LineBreakWrapped LineBreak Number Abbrev Supplied CertLow GapUnknown Gap SuppliedLost Text QuestionMark LostLines Illegible Erasure\",\n  maxTerm: 53,\n  skippedNodes: [0],\n  repeatNodeCount: 2,\n  tokenData: \"+y~Rapq!Wxy!]yz!p!O!P!u!Q![#v!^!_'v!_!`(y!`!a)f!a!b)k!c!}'^!}#O)p#P#Q*]#T#`'^#`#a*b#a#o'^&Fp&Fq+o&Fq&Fr+t~!]O!R~~!bPw~!a!b!e~!hPyz!k~!pOb~~!uOx~~!zQ!Q~!Q![#Q!a!b#n~#VQi~!Q![#Q#`#a#]~#`P#]#^#c~#fP#b#c#i~#nOi~~#sPi~#`#a#]~#{S_P!O!P$X!Q![#v!c!}'^#T#o'^~$^T^Ppq$m}!O$r#V#W%P#Y#Z%t#d#e&uP$rO^P~$wP]~pq$z~%PO]~Q%SP#c#d%VQ%YP#`#a%]Q%`P#i#j%cQ%fP#a#b%iQ%lP#b#c%oQ%tOZQ~%wP#f#g%z~%}P#T#U&Q~&TP#Z#[&W~&ZP#a#b&^~&aP#X#Y&d~&gP#b#c&j~&mP#h#i&p~&uOX~Q&xP#T#U&{Q'OP#f#g'RQ'UP#h#i'XQ'^OVQQ'aS!O!P'm!Q!['^!c!}'^#T#o'^Q'pQ#V#W%P#d#e&u~'{Qy~!_!`(R!f!g(W~(WOq~~(ZP!_!`(^~(aP!O!P(d~(iQv~#f#g(o#j#k(t~(tOs~~(yOu~~)OQ!S~!`!a)U!f!g)Z~)ZOr~~)^P!`!a)a~)fOt~~)kOz~~)pOg~~)uP!P~!O!P)x~)}P}~!a!b*Q~*TP#P#Q*W~*]O|~~*bO!O~R*eU!O!P'm!Q!['^!c!}'^#T#]'^#]#^*w#^#o'^R*zU!O!P'm!Q!['^!c!}'^#T#b'^#b#c+^#c#o'^R+cS!TP!O!P'm!Q!['^!c!}'^#T#o'^~+tO!U~~+yO!V~\",\n  tokenizers: [charsToken, unclearToken, 0, 1],\n  topRules: {\"Document\":[0,2]},\n  tokenPrec: 255\n})\n", "import { Tree, TreeCursor } from \"@lezer/common\";\nimport { parser } from \"../parser/leiden+/parser.js\";\n\nconst blockElements = ['Recto', 'Verso', 'Fragment', 'Part', 'Div'];\n\nexport function leidenPlus2epiDoc(input: string, root: Tree = parser.parse(input)) {\n    function text(node:TreeCursor) {\n        return input.substring(node.from, node.to);\n    }\n\n    const stack:string[] = [];\n    const xml:string[] = [];\n    let needsWrap = false;\n    let wrapper = 'ab';\n    let value;\n    root.iterate({\n        enter: (node:TreeCursor) => {\n            if (node.type.isError) {\n                xml.push(`<!-- Error:${text(node)} -->`);\n                return;\n            }\n            const name = node.name;\n            switch (name) {\n                case 'Document':\n                    let count = 0;\n                    if (node.firstChild()) {\n                        do {\n                            count++;\n                            if (blockElements.includes(node.type.name)) {\n                                wrapper = 'div';\n                            }\n                            needsWrap = needsWrap || node.type.name === 'Inline';\n                        } while (node.nextSibling());\n                    }\n                    needsWrap = count > 1 || needsWrap;\n                    if (needsWrap) {\n                        xml.push(`<${wrapper}>\\n`);\n                    }\n                    node.parent();\n                    break;\n                case 'Text':\n                case 'Number':\n                    xml.push(text(node));\n                    break;\n                case 'LineBreak':\n                    node.firstChild();\n                    value = /^([0-9]+)\\..*$/.exec(text(node));\n                    xml.push(`<lb n=\"${value ? value[1] : ''}\"/>`);\n                    break;\n                case 'LineBreakWrapped':\n                    node.firstChild();\n                    value = /^([0-9]+)\\..*$/.exec(text(node));\n                    xml.push(`<lb n=\"${value ? value[1] : ''}\" break=\"no\"/>`);\n                    break;\n                case 'Div':\n                    xml.push(\"<ab>\")\n                    break;\n                case 'Recto':\n                case 'Verso':\n                    xml.push('<div n=\"r\" type=\"textpart\">');\n                    break;\n                case 'Fragment':\n                    node.firstChild();\n                    value = /^([0-9]+)\\..*$/.exec(text(node));\n                    xml.push(`<div n=\"${value ? value[1] : ''}\" subtype=\"fragment\" type=\"textpart\">`);\n                    break;\n                case 'Part':\n                    node.firstChild();\n                    value = /^([a-zA-Z0-9]+)\\..*$/.exec(text(node));\n                    xml.push(`<div n=\"${value ? value[1] : ''}\" subtype=\"part\" type=\"textpart\">`)\n                    break;\n                case 'Column':\n                    node.firstChild();\n                    value = /^([a-zA-Z0-9]+)\\..*$/.exec(text(node));\n                    xml.push(`<div n=\"${value ? value[1] : ''}\" subtype=\"column\" type=\"textpart\">`)\n                    break;\n                case 'Unclear':\n                    const content = text(node);\n                    let stripped = '';\n                    for (let i = 0; i < content.length; i++) {\n                        const codepoint = content.codePointAt(i);\n                        if (codepoint && codepoint !== 0x0323) {\n                            stripped += String.fromCodePoint(codepoint);\n                        }\n                    }\n                    xml.push(`<unclear>${stripped}</unclear>`);\n                    return false;\n                case 'Gap':\n                    node.next(true);\n                    xml.push(`<gap reason=\"lost\" quantity=\"${text(node)}\" unit=\"character\"/>`);\n                    return false;\n                case 'GapUnknown':\n                    xml.push(`<gap reason=\"lost\" extent=\"unknown\" unit=\"character\"/>`);\n                    return false;\n                case 'Illegible':\n                    value = /^\\.([0-9?]+)(lin)?$/.exec(text(node));\n                    if (value) {\n                        if (value[2] === 'lin') {\n                            xml.push(`<gap reason=\"illegible\" quantity=\"${value ? value[1]: ''}\" unit=\"line\"/>`);\n                        } else if (value[1] === '?') {\n                            xml.push(`<gap reason=\"illegible\" extent=\"unkown\" unit=\"character\"/>`);\n                        } else {\n                            xml.push(`<gap reason=\"illegible\" quantity=\"${value ? value[1]: ''}\" unit=\"character\"/>`);\n                        }\n                    }\n                    return false;\n                case 'Erasure':\n                    xml.push('<del rend=\"erasure\">');\n                    break;\n                case 'LostLines':\n                    value = /^lost\\.([0-9?]+)lin$/.exec(text(node));\n                    if (value) {\n                        if (value[1] === '?') {\n                            xml.push(`<gap reason=\"lost\" extent=\"unknown\" unit=\"line\"/>`);\n                        } else {\n                            xml.push(`<gap reason=\"lost\" quantity=\"${value ? value[1]: ''}\" unit=\"line\"/>`);\n                        }\n                    }\n                    return false;\n                case 'Abbrev':\n                    if (stack.length > 0) {\n                        node.lastChild();\n                        value = text(node);\n                        if (value.length > 0 && value.charAt(value.length - 1) === '?') {\n                            xml.push(`<ex cert=\"low\">`);\n                        } else {\n                            xml.push(`<ex>`);\n                        }\n                        node.parent();\n                    } else {\n                        xml.push('<expan>');\n                    }\n                    stack.push('expan');\n                    break;\n                case 'Supplied':\n                    node.lastChild();\n                    if (node.name === 'CertLow') {\n                        xml.push('<supplied reason=\"omitted\" cert=\"low\">');\n                    } else {\n                        xml.push('<supplied reason=\"omitted\">');\n                    }\n                    node.parent();\n                    break;\n                case 'SuppliedLost':\n                    node.lastChild();\n                    if (node.name === 'CertLow') {\n                        xml.push('<supplied reason=\"lost\" cert=\"low\">');\n                    } else {\n                        xml.push('<supplied reason=\"lost\">');\n                    }\n                    node.parent();\n                    break;\n                case 'CertLow':\n                    return false;\n                case 'QuestionMark':\n                    if (stack.length < 2) {\n                        xml.push('?');\n                    }\n                    return false;\n                case 'Inline':\n                    break;\n                default:\n                    xml.push(`<${name}>`);\n                    break;\n            }\n        },\n        leave: (node) => {\n            switch (node.name) {\n                case 'Document':\n                    if (needsWrap) {\n                        xml.push(`\\n</${wrapper}>`);\n                    }\n                    break;\n                case 'Abbrev':\n                    if (stack.length > 1) {\n                        const last = xml[xml.length - 1];\n                        if (last.endsWith('?')) {\n                            xml[xml.length - 1] = last.substring(0, last.length - 2);\n                        }\n                        xml.push('</ex>');\n                    } else {\n                        xml.push('</expan>');\n                    }\n                    stack.pop();\n                    break;\n                case 'Div':\n                    xml.push('</ab>');\n                    break;\n                case 'Recto':\n                case 'Verso':\n                case 'Fragment':\n                case 'Part':\n                case 'Column':\n                    xml.push('</div>\\n');\n                    break;\n                case 'Supplied':\n                case 'SuppliedLost':\n                    xml.push('</supplied>');\n                    break;\n                case 'Erasure':\n                    xml.push('</del>');\n                    break;\n            }\n        }\n    });\n    if (root.type.name === 'Inline') {\n        xml.push('</ab>');\n    }\n    return xml.join('');\n}\n"],
  "mappings": "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",
  "names": []
}
